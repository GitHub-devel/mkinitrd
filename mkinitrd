#! /bin/bash

# mkinitrd - create the initramfs images
# usage: see below usage() or call with -h
#
# Copyright (C) 1999-2005 SuSE Linux Products GmbH, Nuernberg, Germany
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
# USA.

# This file is kept in the following CVS repository:
#
# $Source: /suse/yast2/cvsroot/mkinitrd/mkinitrd,v $
# $Revision: 1.312.2.58 $

usage() {
    cat<<EOF
	Create initial ramdisk images that contain all kernel modules
	needed in the early boot process, before the root file system
	becomes available. This usually includes SCSI and/or RAID
	modules, a file system module for the root file system, or
	a network interface driver module for dhcp.

        mkinitrd [options]

        options:
          -h               This Text.
          -k "kernel list" List of kernel images for which initrd files
                           are created. Defaults to all kernels found
			   in /boot.
          -i "initrd list" List of file names for the initrd; position
	  		   have match to "kernel list". Defaults to all
			   all kernels found in /boot.
          -m "module list" Modules to include in initrd. Defaults to the
                           INITRD_MODULES variable in /etc/sysconfig/kernel.
          -u "DomU module list" Modules to include in initrd. Defaults to
                           the DOMU_INITRD_MODULES variable in
                           /etc/sysconfig/kernel.
          -f "feature list" Features to be enabled when generating initrd.
                           Available features are:
                           iscsi, md, mpath, lvm, lvm2, evms
          -b boot_dir      Boot directory. Defaults to /boot.
          -d root_device   Root device. Defaults to the device from which
                           / is mounted. Overrides the rootdev enviroment
			   variable if set.
	  -s size          Add splash animation and bootscreen to initrd.
	  -t tmp_dir       Temporary directory. Defaults to /var/tmp.
	  -D interface     Run dhcp on the specified interface.
	  -I interface     Configure the specified interface statically.
	  -a acpi_dsdt     Attach compiled ACPI DSDT (Differentiated System
	  		   Description Table) to initrd. This replaces the
			   DSDT of the BIOS. Defaults to the ACPI_DSDT
			   variable in /etc/sysconfig/kernel.
          -e               Use static binaries where possible.
          -l keyfile       LUKS Key for decryption.
	  -V script        Vendor specific script to run in linuxrc.
	  -M map           System.map file to use.
EOF
    exit
}

# Readlink is not present on some older distributions: emulate it.
readlink() {
    local path=$1 ll

    if [ -L "$path" ]; then
	ll="$(LC_ALL=C ls -l "$path" 2> /dev/null)"
	echo "${ll/* -> }"
    else
	return 1
    fi
}

default_kernel_images() {
    local regex kernel_image kernel_version version_version initrd_image
    local qf='%{NAME}-%{VERSION}-%{RELEASE}\n'

    case "$(uname -m)" in
	s390|s390x)
	    regex='image'
	    ;;
	ppc|ppc64)
	    regex='vmlinux'
	    ;;
	*)  regex='vmlinu.'
	    ;;
    esac

    # user mode linux
    if grep -q UML /proc/cpuinfo; then
	    regex='linux'
    fi

    kernel_images=""
    initrd_images=""
    for kernel_image in $(ls /boot \
	    | sed -ne "\|^$regex\(-[0-9.]\+-[0-9]\+-[a-z0-9]\+$\)\?|p") ; do

	# Note that we cannot check the RPM database here -- this
	# script is itself called from within the binary kernel
	# packages, and rpm does not allow recursive calls.

	[ -L "/boot/$kernel_image" ] && continue
	[ "${kernel_image%%.gz}" != "$kernel_image" ] && continue
	kernel_version=$(/sbin/get_kernel_version \
			 /boot/$kernel_image 2> /dev/null)
	initrd_image=$(echo $kernel_image | sed -e "s|${regex}|initrd|")
	if [ "$kernel_image" != "$initrd_image" -a \
	     -n "$kernel_version" -a \
	     -d "/lib/modules/$kernel_version" ]; then
		kernel_images="$kernel_images /boot/$kernel_image"
		initrd_images="$initrd_images /boot/$initrd_image"
	fi
    done
}

# You can specify the root device via the environment variable rootdev (e.g.
# "rootdev=/dev/hda mkinitrd").

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# general configurable parameters

kernel_images=
initrd_images=
modules=
modules_set=
domu_modules=
domu_modules_set=
feature_list=
boot_dir=
splash=off
luks_key=/tmp/luks.key
use_static_binaries=
acpi_dsdt=
use_selinux=
sysmap=
journaldev=

# architecture dependend changes:
case "$(uname -m)" in
    i?86|x86_64)
	splash="auto"
	;;
esac

while getopts :ef:hk:i:m:u:b:d:s:l:St:D:I:V:a:M:j: a ; do
    case $a in
	\:|\?)	case $OPTARG in
		k)  echo "-k requires kernel list parameter"
		    ;;
		i)  echo "-i requires initrd list parameter"
		    ;;
		m)  echo "-m requires module list parameter"
		    ;;
		u)  echo "-u requires module list parameter"
		    ;;
		f)  echo "-f requires feature list parameter"
		    ;;
		b)  echo "-b requires boot dir parameter"
		    ;;
		d)  echo "-d requires root device parameter"
		    ;;
		s)  echo "-s requires image size(s)"
		    ;;
		t)  echo "-t requires tmp dir parameter"
		    ;;
		l)  echo "-l requires LUKS key parameter"
		    ;;
		D)  echo "-D requires dhcp interface parameter"
		    ;;
		I)  echo "-I requires network interface parameter"
		    ;;
		a)  echo "-a requires a DSDT parameter"
		    ;;
		V)  echo "-V requires an executable to run inside linuxrc"
		    ;;
		M)  echo "-M requires the System.map file"
		    ;;	
		j)  echo "-j requires the journal device"
		    ;;	
		*)  echo "Unknown option: -$OPTARG"
		    echo "Try mkinitrd -h"
		    ;;
	    esac
	    exit 1
	    ;;
	e)  use_static_binaries=1
	    ;;
	f)  feature_list=$OPTARG
	    ;;
	k)  kernel_images=$OPTARG
	    ;;
	i)  initrd_images=$OPTARG
	    ;;
	m)  modules=$OPTARG
	    modules_set=1
	    ;;
	u)  domu_modules=$OPTARG
	    domu_modules_set=1
	    ;;
	b)  boot_dir=$OPTARG
	    ;;
	d)  rootdev=$OPTARG
	    ;;
	s)  splash=$OPTARG
	    ;;
	t)  tmp_dir=$OPTARG
	    ;;
	l)  luks_key=$OPTARG
	    ;;
	D)  interface=$OPTARG
	    interface=${interface#/dev/}
	    use_dhcp=1
	    ;;
 	I)  interface=$OPTARG
 	    interface=${interface#/dev/}
 	    use_ipconfig=1
	    ;;
	a)  acpi_dsdt="$OPTARG"
	    ;;
	S)  use_selinux=1
	    ;;
	V)  vendor_init_script="$OPTARG"
	    ;;
	M)  sysmap="$OPTARG"
	    ;;
	j)  journaldev="$OPTARG"
	    ;;
	h)  usage
	    ;;
    esac
done
shift $(( $OPTIND - 1 ))

mkinit_name="mkinitramfs"

if [ -n "$1" ]; then
    root_dir=${1%/}  # strip trailing slash
else
    root_dir=
fi

if [ -n "$boot_dir" ]; then
    boot_dir="${boot_dir#/}"
    boot_dir="/${boot_dir%/}"
else
    boot_dir="/boot"
fi
if [ ! -d "$boot_dir" ]; then
    echo "$boot_dir is not a directory" >&2
    exit 1
fi

if [ -n "$tmp_dir" ]; then
    tmp_dir="/${tmp_dir#/}"  # make sure it is an absolute path
else
    tmp_dir=/var/tmp
fi
if [ ! -d "$tmp_dir" ]; then
    echo "$tmp_dir is not a directory" >&2
    exit 1
fi

# Check if the -k and -i settings are valid.
if [ $(set -- $kernel_images ; echo $#) -ne \
     $(set -- $initrd_images ; echo $#) ]; then
    echo "You have to specify -k and -i, or none of both. The -k" \
         "and -i options must each contain the same number of items." >&2
    exit 1
fi

# Mount /usr, required for ldd and other tools to create the initrd tree
mounted_usr=
if [ ! -x /usr/bin/ldd ]; then
  mounted_usr=/usr
  if ! mount -n -v /usr ; then
    echo "/usr/bin/ldd not available and mount /usr failed." \
         "mkinitrd does not work without it." >&2
    exit 1
  fi
fi

# Mount /proc if not already done so
mounted_proc=
if [ ! -e /proc/mounts ]; then
  mounted_proc=/proc
  mount -n -t proc proc $mounted_proc
fi

# And /sys likewise
mounted_sys=
if [ ! -d /sys/devices ] ; then
    mounted_sys=/sys
    mount -n -t sysfs none /sys
fi

if [ -z "$kernel_images" -o -z "$initrd_images" ]; then
    default_kernel_images
fi

# Check which shell and insmod binaries to use in initrd.
initrd_shell_dynamic=/bin/bash
if [ -n "$use_static_binaries" ]; then
    if [ -x /bin/ash.static ]; then
	initrd_shell=/bin/ash.static
    else
	initrd_shell=/bin/ash
    fi
else
    initrd_shell=$initrd_shell_dynamic
fi
# The shell-bang line to use inside initrd.
shebang=$initrd_shell
shebang=${shebang%.static}

[ -x /sbin/insmod ] \
    && initrd_insmod_dynamic=/sbin/insmod
if [ -n "$use_static_binaries" ]; then
    initrd_insmod=/sbin/insmod.static
else
    initrd_insmod=$initrd_insmod_dynamic
fi

[ -x /sbin/modprobe ] \
    && initrd_modprobe_dynamic=/sbin/modprobe
if [ -n "$use_static_binaries" ]; then
    initrd_modprobe=/sbin/modprobe.static
else
    initrd_modprobe=$initrd_modprobe_dynamic
fi

# maximum initrd size
image_blocks=40960
image_inodes=2048

# handle splash screen
case "$splash" in
off)
    splashsizes= ;;
auto)
    unset ${!splash_size_*}
    modes=
    for file in $root_dir/{etc/lilo.conf,boot/grub/menu.lst,proc/cmdline}; do
	[ -e $file ] || continue
 	modes="$modes $(sed -e '/^[ \t]*#/d' $file \
			| sed -ne 's/^.*vga[ \t]*=[ \t]*\([^ \t]*\).*/\1/p' \
			| sed -ne '/^\([0-9]\+\|0[xX][0-9a-fA-F]\+\)$/p')"
    done

    for mode in $modes; do
	case $(($mode)) in  # $((...)) : Convert 0xFOO to decimal
	785|786) splash_size_640x480=1 ;;
	788|789) splash_size_800x600=1 ;;
	791|792) splash_size_1024x768=1 ;;
	794|795) splash_size_1280x1024=1 ;;
	*)       vgahex=$(printf 0x%04x "$(($mode))")
		 if [ -x /usr/sbin/hwinfo ] ; then
		     size=$(/usr/sbin/hwinfo --framebuffer | \
			 sed -ne 's/^.*Mode '$vgahex': \([^ ]\+\) .*$/\1/p' \
			 2>/dev/null)
		     eval splash_size_$size=1
		 fi ;;
        esac
    done
    # Get current modes from fb
    for fb in /sys/class/graphics/fb* ; do
	if [ -d $fb ] && [ -f $fb/virtual_size ] ; then
	    size=$(sed -ne 's/,/x/p' $fb/virtual_size)
	    eval splash_size_$size=1
	fi
    done
    splashsizes="$(for x in ${!splash_size_*}; do
			echo ${x#splash_size_}
		   done)"
    unset ${!splash_size_*}
    ;;
*)
    splashsizes=$splash ;;
esac

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# should be nothing to change below...

PATH=/sbin:/usr/sbin:$PATH

# Fixup old installations
unset CDPATH

work_dir=$(mktemp -qd $tmp_dir/${mkinit_name}.XXXXXX)
if [ $? -ne 0 ]; then
	echo "$0: Can't create temp dir, exiting." >&2
	exit 1
fi

umount_proc() {
    [ "$mounted_proc" ] && umount -n $mounted_proc
    mounted_proc=
    [ "$mounted_sys" ] && umount -n $mounted_sys
    mounted_sys=
    [ "$mounted_usr" ] && umount -v -n $mounted_usr
    mounted_usr=
}

cleanup() {
    rm -f $tmp_initrd $tmp_initrd.gz
    initrd_bins=()
}

cleanup_finish() {
    umount_proc
    [ -d "$work_dir" ] && rm -rf $work_dir
}

handle_terminate() {
    echo "(received signal)

Interrupted, cleaning up." >&2
    cleanup
    cleanup_finish
    exit 255
}

trap handle_terminate 1 2 3 15

error() {
    echo "$2" >&2
    cleanup
    cleanup_finish
    exit $1
}

oops() {
    exit_code=$1
    shift
    echo "$@" >&2
}

is_xen_kernel() {
    local kversion=$1
    local cfg

    for cfg in ${root_dir}/boot/config-$kversion $root_dir/lib/modules/$kversion/build/.config
    do
	test -r $cfg || continue
	grep -q "^CONFIG_XEN=y\$" $cfg
	return
    done
    test $kversion != "${kversion%-xen*}"
    return 
}

# Check if module $1 is listed in $modules.
has_module() {
    local module
    # Always use underscores here
    module=$(echo $1 | sed 's/-/_/g')
    case " $modules " in
	*" $module "*)   return 0 ;;
    esac
    return 1
}

# Check if any of the modules in $* are listed in $modules.
has_any_module() {
    local module
    for module in "$@"; do
	has_module "$module" && return 0
    done
}

# Add module $1 at the end of the module list.
add_module() {
    local module
    for module in "$@"; do
	# Always use underscores here
	module=$(echo $module | sed 's/-/_/g')
	has_module "$module" || modules="$modules $module"
    done
}

# Install a binary file
cp_bin() {
    cp -a "$@" \
    || exit_code=1

    # Remember the binaries installed. We need the list for checking
    # for dynamic libraries.
    while [ $# -gt 1 ]; do
	initrd_bins[${#initrd_bins[@]}]=$1
	shift
   done
}

# Resolve dynamic library dependencies. Returns a list of symbolic links
# to shared objects and shared object files for the binaries in $*.
shared_object_files() {
    local LDD CHROOT initrd_libs lib_files lib_links lib link

    LDD=/usr/bin/ldd
    if [ ! -x $LDD ]; then
	error 2 "I need $LDD."
    fi

    initrd_libs=( $(
	$LDD "$@" \
	| sed -ne 's:\t\(.* => \)\?\(/.*\) (0x[0-9a-f]*):\2:p'
    ) )

    # Evil hack: On some systems we have generic as well as optimized
    # libraries, but the optimized libraries may not work with all
    # kernel versions (e.g., the NPTL glibc libraries don't work with
    # a 2.4 kernel). Use the generic versions of the libraries in the
    # initrd (and guess the name).
    local n optimized
    for ((n=0; $n<${#initrd_libs[@]}; n++)); do
	lib=${initrd_libs[$n]}
	optimized="$(echo "$lib" | sed -e 's:.*/\([^/]\+/\)[^/]\+$:\1:')"
	lib=${lib/$optimized/}
	if [ "${optimized:0:3}" != "lib" -a -f "$lib" ]; then
	    #echo "[Using $lib instead of ${initrd_libs[$n]}]" >&2
	    initrd_libs[$n]="${lib/$optimized/}"
	fi
    done

    for lib in "${initrd_libs[@]}"; do
	case "$lib" in
	linux-gate*)
	    # This library is mapped into the process by the kernel
	    # for vsyscalls (i.e., syscalls that don't need a user/
	    # kernel address space transition) in 2.6 kernels.
	    continue ;;
	/*)
	    lib="${lib:1}" ;;
	*)
	    # Library could not be found.
	    oops 7 "Dynamic library $lib not found"
	    continue ;;
	esac

	while [ -L "/$lib" ]; do
	    echo $lib
	    link="$(readlink "/$lib")"
	    if [ x"${link:0:1}" == x"/" ]; then
	        lib=${link#/}
	    else
	        lib="${lib%/*}/$link"
	    fi
	done
	echo $lib
    done \
    | sort -u
}

# Resolve module dependencies and parameters. Returns a list of modules and
# their parameters.
resolve_modules() {
    local kernel_version=$1 module
    shift

    for module in "$@"; do
	local with_modprobe_conf
	module=${module%.o}  # strip trailing ".o" just in case.
	module=${module%.ko}  # strip trailing ".ko" just in case.
	if [ -e /etc/modprobe.conf ]; then
	    with_modprobe_conf="-C /etc/modprobe.conf"
	fi
	module_list=$(/sbin/modprobe $with_modprobe_conf \
	    --set-version $kernel_version --ignore-install \
	    --show-depends $module 2> /dev/null \
	    | sed -ne 's:.*insmod /\?::p' )
	if [ "$module" != "af_packet" ] && [ -z "$module_list" ]; then
	    oops 7 "Cannot determine dependencies of module $module." \
		"Is modules.dep up to date?"
	fi
	echo "$module_list"
    done \
    | awk ' # filter duplicates: we must not reorder modules here!
	NF == 0     { next }
	$1 in seen  { next }
		    { seen[$1]=1
		      # drop module parameters here: modprobe in the initrd
		      # will pick them up again.
		      print $1
		    }
    '
    rm -f $temp
}

# Test if file $1 is smaller than file $2 (kilobyte granularity)
smaller_file() {
    local size1=$(ls -l "$1" |awk '{print $5}')
    local size2=$(ls -l "$2" |awk '{print $5}')
    [ $size1 -lt $size2 ]
}

# Cat from stdin to linuxrc, removing leading whitespace up to pipe symbol.
# Note that here documents can only be indented with tabs, not with spaces.
cat_linuxrc() {
    sed 's/^[ \t]*|//' >> $linuxrc
    echo >> $linuxrc
}

# Attach ACPI DSDT if necessary.
attach_dsdt() {
    local initrd_image=$1

    if [ -z "$acpi_dsdt" ]; then
	if [ -f /etc/sysconfig/kernel ]; then
	    . /etc/sysconfig/kernel
	    acpi_dsdt="$ACPI_DSDT"
	fi
    fi
    if [ -z "$acpi_dsdt" ]; then
	return
    fi
    if [ ! -f "$acpi_dsdt" ]; then
	oops 2 "ACPI DSDT $acpi_dsdt does not exist."
	return
    fi
    if ! grep -q "DSDT" "$acpi_dsdt" ; then
	oops 2 "File $acpi_dsdt is not a valid ACPI DSDT. Ignoring."
	return
    elif grep -qE 'DefinitionBlock' "$acpi_dsdt" ; then
    	oops 2 "ACPI DSDT $acpi_dsdt does not seem to be in binary form." \
	       "Will not attach this to $initrd_image."
	return
    fi

    cp "$acpi_dsdt" $tmp_mnt/DSDT.aml

    echo -e "ACPI DSDT:\t$acpi_dsdt"
}

# Check for IDE module
check_ide_modules_pcimap() {
    local ide_modules

    pcimap_file=$1
    vendor_id=$2
    device_id=$3
	
    pci_vendor_id=$(printf "0x%08x" $(($2)))
    pci_device_id=$(printf "0x%08x" $(($3)))
    while read pcimap_module rest; do
	if [ "$pcimap_module" == "ata_piix" ]; then
	    # FIXME: add_module will have no effect in a sub-shell...
	    add_module "ahci"
	    ide_modules="$ide_modules ahci"
	fi
	ide_modules="$ide_modules $pcimap_module"
    done < <(grep "$pci_vendor_id $pci_device_id" $pcimap_file)

    echo "$ide_modules"
}

check_ide_modules_hwinfo() {
    local ide_modules
    local kernel_version

    kernel_version=$(basename ${modules_dir})

    pci_id_vendor=$1
    pci_id_device=$2
    pci_revision=$3
    pci_subid_vendor=$4
    pci_subid_device=$5

    while read hwinfo_module; do
	if [ "$hwinfo_module" == "ata_piix" ]; then
	    # Always add ahci prior to ata_piix
	    ide_modules="$ide_modules ahci $hwinfo_module"
	elif [ "$hwinfo_module" != "ahci" ]; then
	    # Skip ahci module from hwinfo output
	    ide_modules="$ide_modules $hwinfo_module"
	fi
    done < <(hwinfo --kernel-version $kernel_version \
	            --db "pci ${pci_id_vendor:+vendor=$pci_id_vendor} 
                         ${pci_id_device:+device=$pci_id_device} 
                         ${pci_subid_vendor:+subvendor=$pci_subid_vendor}  
                         ${pci_subid_device:+subdevice=$pci_subid_device} 
                         ${pci_revision:+revision=$pci_revision}")

    echo "$ide_modules"
}

# Check for IDE modules, new version
# We'll be asking hwinfo to return the proper module for us
check_ide_modules() {
    local modules_dir=$1 ide_modules

    # Check for PCI bus
    if [ ! -d /proc/bus/pci ]; then
        # Not found, no error
        return
    fi

    pcimap_file="${modules_dir}/modules.pcimap"

    if [ ! -f "$pcimap_file" ] ; then
	echo "No modules.pcimap file found" >&2
	return
    fi

    while read pci_id none class_id dev_id rev_id; do
	if [ "$class_id" == "0101:" ] ; then
	    ide_slots="$ide_slots $pci_id"
	fi
    done < <(/sbin/lspci -n)

    for pci_id in $ide_slots; do
	eval $(/sbin/lspci -nmv -s $pci_id | sed '/Class.*/d' | sed 's/:[[:blank:]]/=/g')
	pci_id_vendor=$(printf "0x%x" $((0x$Vendor)))
	pci_id_device=$(printf "0x%x" $((0x$Device)))
	pci_revision=$(printf "0x%x" $((0x$Rev)))
	if [ "$SVendor" ] ; then
	    pci_subid_vendor=$(printf "0x%x" $((0x$SVendor)))
	fi
	if [ "$SDevice" ] ; then
	    pci_subid_device=$(printf "0x%x" $((0x$SDevice)))
	fi
	: Slot ${pci_id}: $pci_id_vendor $pci_id_device $pci_subid_vendor $pci_subid_device
	ide_modules=$(check_ide_modules_hwinfo $pci_id_vendor $pci_id_device $pci_revision $pci_subid_vendor $pci_subid_device)
	if [ -z "$ide_modules" ]; then
	    ide_modules=$(check_ide_modules_pcimap $pcimap_file $pci_id_vendor $pci_id_device)
	fi

	    if [ "$ide_modules" ]; then
		for module in $ide_modules; do
		    # Only add ahci module if ata_piix is not loaded already
		    if [ "$module" == "ahci" ]; then
			has_module ata_piix || add_module $module
		    else
			add_module $module
		    fi
		done
		# All IDE modules are now loaded later
		# if grep -q ide-disk ${modules_dir}/modules.dep; then
		#     add_module ide-disk
		# fi
		# IDE-floppy is considered obsolete
		# if grep -q ide-floppy ${modules_dir}/modules.dep; then
		#     add_module ide-floppy
		# fi
		# if grep -q ide-cd ${modules_dir}/modules.dep; then
		#     add_module ide-cd
		# fi
		echo
	    fi
    done
}

# NOTE: The mkdevn, devmajor and block_driver functions are reused
#       inside the initrd, so keep them compatible with ash !!!
#

# Convert a major:minor pair into a device number
mkdevn() {
    local major=$1 minor=$2 minorhi minorlo
    major=$(($major * 256))
    minorhi=$(($minor / 256))
    minorlo=$(($minor % 256))
    minor=$(($minorhi * 256 * 4096))
    echo $(( $minorlo + $major + $minor ))
}

# Extract the major part from a device number
devmajor() {
    local devn=$(($1 / 256))
    echo $(( $devn % 4096 ))
}

# Extract the minor part from a device number
devminor() {
    local devn=${1:-0} minorhi minorlo
    minorlo=$(( $devn % 256 ))
    minorhi=$(( $devn / 1048576 ))
    echo $(( $minorhi * 256 + $minorlo )) 
}

block_driver() {
    local devn block major driver
    case "$1" in
    /dev/*) devn=$(devnumber $1 2> /dev/null) ;;

    *:*)    # major:minor
	    set -- $(IFS=: ; echo $1)
	    devn=$(mkdevn $1 $2) ;;

    [0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])
	    # hex device number
	    devn=$((0x$1)) ;;
    esac

    [ -z "$devn" ] && return 1
    major=$(devmajor $devn)
    driver=$(cat /proc/devices | sed -n "/^Block devices:/{n;: n;s/^[ ]*$major \(.*\)/\1/p;n;b n}")
    case "$driver" in
	Block*)
	    return 1
	    ;;
	*)
	    echo $driver
	    return 0
	    ;;
    esac
}

# (We are using a devnumber binary inside the initrd.)
devnumber() {
    set -- $(ls -lL $1)
    mkdevn ${5%,} $6
}

# Calculate the netmask for a given prefix
calc_netmask() {
    local prefix=$1
    local netmask

    netmask=
    num=0
    while (( $prefix >= 8 )) ; do
	if (( $num > 0 )) ; then
	    netmask="${netmask}.255"
	else
	    netmask="255"
	fi
	prefix=$(($prefix - 8))
	num=$(($num + 1))
    done
    if (( $prefix > 0 )) ; then
	mask=$(( 0xFF00 >> $prefix ))
    else
	mask=0
    fi
    netmask="${netmask}.$(( $mask & 0xFF ))"
    num=$(($num + 1))
    while (( $num < 4 )) ; do
	netmask="${netmask}.0"
	num=$(($num + 1))
    done
    echo $netmask
}

# Get the interface information for ipconfig
get_ip_config() {
    local iface
    local iplink
    local iproute

    iface=$1
    iplink=$(ip addr show dev $iface | grep "inet ")

    set -- $iplink
    if [ "$1" == "inet" ]; then
	shift

	ipaddr=${1%%/*}
	prefix=${1##*/}
	shift 
	if [ "$1" == "peer" ] ; then
	    shift
	    peeraddr=${1%%/*}
	    prefix=${1##*/}
	fi
	netmask=$(calc_netmask $prefix)
	bcast=$3
    fi
    iproute=$(ip route list dev $iface | grep default)
    if [ $? -eq 0 ]; then
	set -- $iproute
	gwaddr=$3
    fi
    hostname=$(hostname)
    echo "$ipaddr:$peeraddr:$gwaddr:$netmask:$hostname:$iface:none"
}  

check_iscsi_root() {
    local devname=$1
    local sysfs_path

    sysfs_path=$(udevinfo -q path -n $devname 2> /dev/null)
    if [ -z "$sysfs_path" ] || [ ! -d /sys$sysfs_path ] ; then
	return;
    fi

    pushd /sys$sysfs_path > /dev/null
    if [ ! -d device ] ; then
	cd ..
    fi

    if [ ! -d device ] ; then
	# no device link; return
	popd > /dev/null
	return;
    fi

    cd -P device
    cd ../..

    if [ -d connection* ]; then
	cd -P connection*
	cid=${PWD#*connection}
	sid=${cid%%:*}
	if [ -d /sys/class/iscsi_session/session$sid ]; then
	    cd -P /sys/class/iscsi_session/session$sid
	    echo $(basename $PWD)
	fi
    fi
    popd > /dev/null
}

get_default_interface() {
    local ifname

    # Determine the default network interface
    if [ -f /etc/install.inf ] ; then
	# Get info from install.inf during installation
	BOOTPROTO=$(sed -ne 's/NetConfig: \(.*\)/\1/p' /etc/install.inf)
	ifname=$(sed -ne 's/Netdevice: \(.*\)/\1/p' /etc/install.inf)
	macaddress=$(sed -ne 's/HWAddr: \(.*\)/\1/p' /etc/install.inf)
	if [ "$macaddress" ] ; then
	    for dev in /sys/class/net/* ; do
		read tmpmac < $dev/address
		if [ "$tmpmac" == "$macaddress" ] ; then
		    ifname=${dev##*/}
		fi
	    done
	fi
    else
    for cfg in /etc/sysconfig/network/ifcfg-*; do
	if [ $(basename $cfg) = "ifcfg-lo" ] ; then
	    continue;
	fi
	eval $(grep STARTMODE $cfg)
	if [ "$STARTMODE" = "nfsroot" ]; then
	    cfgname=$(basename $cfg)
	    ifname=$(getcfg-interface ${cfg#*/ifcfg-})
	    eval $(grep BOOTPROTO $cfg)
	    break;
	fi
    done
    fi
    echo $ifname/$BOOTPROTO
}

###################################################################
#
# S/390 specific procedures
#
s390_check_lvm2() {
    local vgname
    local devname
    
    # Check whether the LVM is on zfcp or DASD
    vgname=$(lvdisplay -c $1 | cut -d : -f 2)

    if [ "$vgname" ]; then
	for devname in $(pvdisplay -c | grep $vgname | cut -d : -f 1); do
	    case "$devname" in
		*/dasd*)
		    s390_enable_dasd=1
		    ;;
		*/sd*)
		    s390_enable_zfcp=1
		    ;;
		*)
		    ;;
	    esac
	done
    fi
}

s390_check_evms() {
    local evms_cmd
    local evms_reg
    local evms_cont
    local evms_seg
    local evms_dsk

    if [ ! -x /sbin/evms ]; then
	return 1
    fi

    if [ -n "$1" ]; then
	evms_cmd="q:r,v=$1"

	while read a b c d; do
	    if [ "$a $b" = "Region Name:" ]; then
		evms_reg="$evms_reg $c"
	    fi
	done < <( echo "$evms_cmd" | /sbin/evms -s -b )
    fi

    for reg in $evms_reg; do
	evms_cmd="q:c,r=$reg"
	
	while read a b c d; do
	    if [ "$a $b" = "Container Name:" ]; then
		evms_cont="$evms_cont $c"
	    fi
	done < <(echo "$evms_cmd" | /sbin/evms -s -b )
    done
    
    for cont in $evms_cont; do
	evms_cmd="q:s,c=$cont"
	
	while read a b c d; do
	    if [ "$a $b" = "Segment Name:" ]; then
		evms_seg="$evms_seg $c"
	    fi
	done < <(echo "$evms_cmd" | /sbin/evms -s -b )
    done

    for seg in $evms_seg; do
	evms_cmd="q:d,s=$seg"
	while read a b c d; do
	    if [ "$a $b $c" = "Logical Disk Name:" ]; then
		evms_dsk="$evms_dsk $d"
	    fi
	done < <(echo "$evms_cmd" | /sbin/evms -s -b )
    done

    for dsk in $evms_dsk; do
	case $dsk in
	    dasd*)
		s390_enable_dasd=1;
		;;
	    sd*)
		s390_enable_zfcp=1
		;;
	esac
    done
}

s390_check_dasd() {
    local devn=$(devnumber $1)

    for dir in /sys/block/*/*; do
	if [ -d "$dir" ] && [ -f "$dir/dev" ]; then
	    IFS=":" read major minor < $dir/dev
	    if (($devn == $(mkdevn $major $minor) )); then
		path=$dir
		break;
	    fi
	fi
    done
    if [ "$path" ] && [ -d ${path}/../device ]; then
	if [ -r ${path}/../device/discipline ]; then
	    s390_enable_dasd=1
	fi
    fi
}

s390_check_zfcp() {
    local devn=$(devnumber $1)

    for dir in /sys/block/*/*; do
	if [ -d "$dir" ] && [ -f "$dir/dev" ]; then
	    IFS=":" read major minor < $dir/dev
	    if (($devn == $(mkdevn $major $minor) )); then
		path=$dir
		break;
	    fi
	fi
    done
    
    if [ "$path" ] && [ -d "$path/../device" ] && [ -e "$path/../device/scsi_level" ] ; then
	s390_enable_zfcp=1
    fi
}

# Detect all zfcp disks
# We need to activate all disks in the same order
# as found in the running system to get the same
# behaviour during booting.
s390_zfcp_sysfs() {
    local dev_dir
    local fcp_disk_hba
    local fcp_disk_wwpn
    local fcp_disk_lun

    if [ "$s390_enable_zfcp" ] ; then
	# Root is on SCSI, detect all SCSI devices
	for dev_dir in /sys/block/sd? /sys/block/sd?? /sys/block/sd??? /sys/block/sd???? ; do
	    if [ -d "$dev_dir" ] && [ -e "$dev_dir/device" ]; then
		pushd $dev_dir > /dev/null;
		cd $(readlink device);
		if [ -r ./hba_id ]; then
		    read fcp_disk_hba < ./hba_id
		    read fcp_disk_wwpn < ./wwpn
		    read fcp_disk_lun < ./fcp_lun
	    
		    s390_zfcp_disks="$s390_zfcp_disks $fcp_disk_hba:$fcp_disk_wwpn:$fcp_disk_lun"

		    for id in $s390_zfcp_hbas; do
			if [ "$id" == "$fcp_disk_hba" ]; then
			    fcp_disk_hba=
			fi
		    done
		    [ "$fcp_disk_hba" ] && s390_zfcp_hbas="$s390_zfcp_hbas $fcp_disk_hba"
		else
		    s390_zfcp_hbas="iSCSI"
		    s390_zfcp_disks="iSCSI"
		fi
		popd > /dev/null
	    fi
	done
	if [ "$s390_zfcp_hbas" ] && [ "$s390_zfcp_hbas" != "iSCSI" ] ; then
	    add_module sd_mod
	    add_module zfcp
	fi
    fi

}

s390_dasd_sysfs() {
    local type
    local discipline

    if [ "$s390_enable_dasd" ]; then
	# Root device is on a dasd device, enable all dasd disks
	for dir in /sys/block/dasd[a-z] /sys/block/dasd[a-z][a-z] /sys/block/dasd[a-z][a-z][a-z] ; do
	    if [ -d "$dir" ] && [ -d ${dir}/device ]; then
		pushd $dir > /dev/null
		cd $(readlink device)
		if [ -r ./discipline ]; then
		    read type < ./discipline
		    
		    case $type in
			ECKD)
			    add_module dasd_eckd_mod
			    discipline=0
			    ;;
			FBA)
			    add_module dasd_fba_mod
			    discipline=1
			    ;;
			DIAG)
			    add_module dasd_diag_mod
			    discipline=2
			    ;;
			*)
			    ;;
		    esac
		    s390_dasd_disks="$s390_dasd_disks $(basename $PWD):$discipline"
		fi
		popd > /dev/null
	    fi
	done

    fi
}

s390_dasd_proc() {
    local zipl_conf_with_dasd dasd_module

    if [ -f /etc/zipl.conf ] \
       && grep -q '^[[:space:]]*parameters[[:space:]]*=' \
	    /etc/zipl.conf; then
	    zipl_conf_with_dasd=1
    fi

    if modprobe -c \
       | grep -q '^[[:space:]]*options[[:space:]]\+dasd_mod' ; then
	dasd_module=1
    fi

    if grep -q -e "^dasd" /proc/modules \
       || [ -n "$zipl_conf_with_dasd" ] \
       || [ -n "$dasd_module" ] \
       || has_module dasd_mod ; then

	if [ ! "$zipl_conf_with_dasd" -a ! "$dasd_module" ]; then
	    error 1 "\
The dasd module is required, but no dasd configuration was found in
root_dir/etc/zipl.conf or root_dir/etc/modules.conf."
	fi

	if grep -q ECKD /proc/dasd/devices ; then
	    add_module dasd_eckd_mod
	fi

	if grep -q FBA  /proc/dasd/devices ; then
	    add_module dasd_fba_mod
	fi

	if grep -q DIAG /proc/dasd/devices ; then
	    add_module dasd_diag_mod
	fi
    else
	# /proc not mounted or somesuch. Enable all dasd modules
	add_module dasd_mod
	add_module dasd_eckd_mod
	add_module dasd_fba_mod
	add_module dasd_diag_mod
    fi
}

s390_get_ctc_ccwdevs()
{
    local interface=$1

    if [ ! -d /sys/class/net/$interface/device ] ; then
	error 1 "No device link for interface $interface"
    fi
    pushd /sys/class/net/$interface/device > /dev/null 2>&1
    cd -P cdev0
    cdev0=$(basename $PWD)
    popd > /dev/null 2>&1

    pushd /sys/class/net/$interface/device > /dev/null 2>&1
    cd -P cdev1
    cdev1=$(basename $PWD)
    popd > /dev/null 2>&1

    echo "$cdev0,$cdev1"
}

###################################################################
#
# Create the initrd image $2 for kernel $1 (both are absolute path names).
#
mkinitrd_kernel() {
    local kernel_image=$1 initrd_image=$2
    local kernel_version
    local need_raidstart
    local need_mdadm
    local is_kdump
    local -a features
    local fs_modules drv_modules uld_modules root_modules
    local i

    tmp_mnt=$work_dir/mnt
    tmp_mnt_small=${tmp_mnt}_small
    tmp_msg=$work_dir/msg$$
    vendor_script=$tmp_mnt/vendor_init.sh

    linuxrc=$tmp_mnt/init

    if [ ! -f "$kernel_image" ] ; then
	error 1 "No kernel image $kernel_image found" >&2
    fi

    kernel_version=$(/sbin/get_kernel_version $kernel_image)
    modules_dep=$root_dir/lib/modules/$kernel_version/modules.dep

    #echo -e "Kernel version:\t$kernel_version"
    echo -e "Kernel image:\t$kernel_image"
    echo -e "Initrd image:\t$initrd_image"

    if [ ! -d "/lib/modules/$kernel_version/misc" -a \
	 ! -d "/lib/modules/$kernel_version/kernel" ]; then
	oops 2 "No modules found for kernel $kernel_version"
        return
    fi

    # Check whether this is the kdump kernel
    # NOTE: On IA64 and SLES10, we don't have kernel-kdump but use the normal
    # kernel for dumping. Just include the kdump feature always there
    # to avoid need for rerun mkinitrd when "kdump" package is installed.
    # We don't have such strict size constraints on IA64.
    if [ "${kernel_image%%-kdump}" != "${kernel_image}" ] || \
		[ "$(uname -i)" = "ia64" ]  ; then
	if [ -f /etc/sysconfig/kdump ] ; then
	    . /etc/sysconfig/kdump
	    dumpdev=$KDUMP_DUMPDEV
	fi
	features=(${features[@]} kdump)
	is_kdump=1
    fi

    # Make sure to always include the module for the root filesystem
    # if the root filesystem is modularized.
    if [ -z "$is_kdump" ] && ! has_module "$rootfstype" && \
       grep -qe "$rootfstype\.ko:" $modules_dep; then
	echo "Adding the root filesystem module ($rootfstype)"
	add_module $rootfstype
    fi

    # create an empty initrd
    if ! mkdir $tmp_mnt ; then
	error 1 "could not create temporary directory"
    fi

    # fill the initrd
    mkdir -p $tmp_mnt/{sbin,bin,etc,dev,proc,sys,root}

    mkdir -p -m 4777 $tmp_mnt/tmp

    # Create a dummy /etc/mtab for mount/umount
    echo -n > $tmp_mnt/etc/mtab

    mkdir -p $tmp_mnt${initrd_shell%/*}
    cp_bin $initrd_shell $tmp_mnt$initrd_shell
    if [ $shebang != $initrd_shell ]; then
	ln -s $initrd_shell $tmp_mnt$shebang
    fi
    if [ $shebang != /bin/sh ]; then
	ln -s $shebang $tmp_mnt/bin/sh
    fi
    
    if ! cp_bin $initrd_insmod $tmp_mnt/sbin/insmod 2>/dev/null ; then
	error 5 "no static insmod"
    fi

    # Add modprobe, modprobe.conf*, and a version of /bin/true: modprobe.conf
    # might use it.
    if ! cp_bin $initrd_modprobe $tmp_mnt/sbin/modprobe 2>/dev/null ; then
	error 5 "no static modprobe"
    fi
    cp -r $root_dir/etc/modprobe.conf $root_dir/etc/modprobe.conf.local \
 	  $root_dir/etc/modprobe.d $tmp_mnt/etc
    cat > $tmp_mnt/bin/true <<-EOF
	#! /bin/sh
	:
	EOF
    chmod +x $tmp_mnt/bin/true
 
    # Enable user-selected features
    if [ "$feature_list" ] ; then
	for f in $feature_list ; do
	    case $f in
		iscsi)
		    add_module iscsi_tcp
		    ;;
		mpath)
		    add_module dm-multipath
		    ;;
		lvm2)
		    add_module dm-snapshot
		    add_module dm-crypt
		    add_module dm-zero
		    add_module dm-mirror
		    root_lvm2=1
		    root_dm=1
		    ;;
		lvm)
		    add_module lvm-mod
		    root_lvm=1
		    ;;
		evms)
		    add_module dm-mirror
		    add_module dm-snapshot
		    root_evms=1
		    root_dm=1
		    ;;
		md)
		    add_module raid0
		    add_module raid1
		    add_module raid5
		    add_module linear
		    need_mdadm=1
		    ;;
		kdump)
		    is_kdump=1
		    ;;
		*)
		    error 6 "invalid feature $f"
		    ;;
	    esac
	done
    fi

    # Enable the LUKS encrypted file systems, if any

    if [ -x /usr/sbin/cryptsetup ] ; then
        cryptsetup=/usr/sbin/cryptsetup
    elif [ -x /usr/sbin/cryptsetup-luks ] ; then
        cryptsetup=/usr/sbin/cryptsetup-luks
    elif [ -x /sbin/cryptsetup ] ; then
        cryptsetup=/sbin/cryptsetup
    fi

    if [ -r $luks_key ] ; then
	cp -a $luks_key $tmp_mnt/tmp/luks.key
    fi

    cipherName="Cipher name:"
    cipherMode="Cipher mode:"
    hashSpec="Hash spec:"
    numLuks=0
    for md in $(dmsetup ls | cut -f 1) ; do
        device=`$cryptsetup status $md 2> /dev/null | grep device | cut -f 5 -d' ' `
        if [ -z "$device" ] ; then
            continue;
        elif [[ $device == /dev/loop* ]] ; then
            continue;
        fi
        isLuks=`$cryptsetup isLuks $device &>/dev/null`
        if [ $? == 0 ]; then
            rN=${rootdev#"/dev/mapper/"}
            cipher=`$cryptsetup luksDump $device | grep "$cipherName" | cut -f 2 -d: `
            hash=`$cryptsetup luksDump $device | grep "$hashSpec" | cut -f 2 -d: `
            mode=`$cryptsetup luksDump $device | grep "$cipherMode" | cut -f 3 -d: `

            arch=`uname -m`
            if [ $cipher == "aes" ] ; then
                case "$(uname -m)" in
                    i586)
                        cipher="aes-i586"
                        ;;
                    i686)
                        cipher="aes-i586"
                        ;;
                esac
            fi
            add_module $cipher
            add_module $hash
            add_module $mode
            add_module blkcipher
            add_module cbc
            if [ "/dev/mapper/$md" != "$rootdev" ] ; then
                cryptdev[$numLuks]=$device
                dmname[$numLuks]=$md
                numLuks=$(($numLuks + 1))
	    else
		root_lerfs=1
            fi
	    cp_bin $cryptsetup $tmp_mnt/sbin/cryptsetup
	    cp_bin /usr/bin/clear $tmp_mnt/bin/
        fi
    done

    if [ "$root_lerfs" -o "$numLuks" -ne 0 ] ; then
	features=(${features[@]} LUKS)
    fi

    if [ ! -z "$vendor_init_script" ] ; then
	features=(${features[@]} script\($vendor_script\))
	cp_bin $vendor_init_script $vendor_script
    fi

    if has_module dm-multipath ; then
	add_module dm-round-robin
	add_module dm-emc
	add_module dm-rdac
	add_module dm-hp_sw
	root_mpath=1
	root_dm=1
    fi

    if has_module iscsi_tcp ; then
	features=(${features[@]} iscsi)
	add_module crc32c
	cp_bin /sbin/iscsid $tmp_mnt/sbin/iscsid
	cp_bin /sbin/iscsiadm $tmp_mnt/sbin/iscsiadm
	if [ -x /sbin/fwparam_ibft ] ; then
	    cp_bin /sbin/fwparam_ibft $tmp_mnt/sbin/fwparam_ibft
	    features=(${features[@]} iBFT)
	fi
	# Check for open-iscsi in SLES10 SP1
	if [ -d /etc/iscsi ] ; then
	    mkdir -p $tmp_mnt/etc/iscsi
	    cp -r /etc/iscsi $tmp_mnt/etc
	    mkdir -p $tmp_mnt/var/lock/iscsi
	else
	    cat /etc/initiatorname.iscsi > $tmp_mnt/etc/initiatorname.iscsi
	    mkdir -p $tmp_mnt/var/lib/open-iscsi
	    cp /var/lib/open-iscsi/discovery.db $tmp_mnt/var/lib/open-iscsi
	    cp /var/lib/open-iscsi/node.db $tmp_mnt/var/lib/open-iscsi
	fi
	mkdir -p $tmp_mnt/var/run
	cp_bin /bin/mv $tmp_mnt/bin/mv
	cp_bin /bin/usleep $tmp_mnt/bin/usleep
	cp_bin /bin/basename $tmp_mnt/bin/basename
	# Include programs for static IP configuration
	use_ipconfig=1
	# Always include dhcp programs, too
	use_dhcp=1
	# And we simulate root on iSCSI
	[ -z "$iscsi_root" ] && iscsi_root=session1
    fi

    if [ -n "$s390_dasd_disks" ]; then
	cp_bin /sbin/dasd_configure $tmp_mnt/sbin
	cp_bin /sbin/dasdview $tmp_mnt/sbin
	if [ -x /sbin/dasdinfo ] ; then
	    cp_bin /sbin/dasdinfo $tmp_mnt/sbin
	fi
    fi

    if [ -n "$s390_zfcp_disks" ]; then
	cp_bin /sbin/zfcp_host_configure $tmp_mnt/sbin
	cp_bin /sbin/zfcp_disk_configure $tmp_mnt/sbin
    fi

    features=(${features[@]} initramfs)

    # Programs /sbin
    for prog in killall5 halt reboot; do
	cp_bin /sbin/$prog $tmp_mnt/sbin
    done

    # Programs /bin
    for prog in sed sleep cat cp ln ls pidof mount umount; do
	cp_bin /bin/$prog $tmp_mnt/bin
    done

    # Common utilities
    for bin in chmod mkdir mknod rm; do
	cp_bin /bin/$bin $tmp_mnt/bin
    done

    for file in /lib/mkinitrd/bin/* ; do
	if [ -x $file ] ; then
	    cp_bin $file $tmp_mnt/bin
	fi
    done

    for dir in /lib/mkinitrd/* ; do
	if [ -d "$dir" -a "$dir" != "/lib/mkinitrd/bin" ] ; then
	    [ -d ${tmp_mnt}${dir#/lib/mkinitrd} ] || mkdir ${tmp_mnt}${dir#/lib/mkinitrd}
	    for f in $dir/* ; do
		if [ -f "$f" ] ; then
		    cp -a $f ${tmp_mnt}${dir#/lib/mkinitrd}
		fi
	    done
	fi
    done

    # all dev nodes belong to root, but some may be
    # owned by a group other than root
    # getent passwd | sed '/^root:/s/^\([^:]\+\):[^:]*:\([^:]\+\):\([^:]\+\):.*/\1::\2:\3:::/p;d' > $tmp_mnt/etc/passwd
    echo 'root::0:0:::' > $tmp_mnt/etc/passwd
    echo 'nobody::65534:65533:::' >> $tmp_mnt/etc/passwd
    getent group | sed 's/^\([^:]\+\):[^:]*:\([^:]\+\):.*/\1::\2:/' > $tmp_mnt/etc/group
    (echo 'passwd: files';echo 'group: files') > $tmp_mnt/etc/nsswitch.conf

    if [ -d /lib64 ]; then
	mkdir -p $tmp_mnt/lib64
	for nss_lib in /lib64/libnss_files*; do
	    if [ -f "$nss_lib" ]; then
		cp_bin $nss_lib $tmp_mnt/lib64
	    fi
	done
    else
	mkdir -p $tmp_mnt/lib
	for nss_lib in /lib/libnss_files*; do
	    if [ -f "$nss_lib" ]; then
		cp_bin $nss_lib $tmp_mnt/lib
	    fi
	done
    fi

    cp_bin /sbin/udevd $tmp_mnt/sbin/
    cp_bin /sbin/udevtrigger $tmp_mnt/sbin/
    cp_bin /sbin/udevsettle $tmp_mnt/sbin/
    cp_bin /usr/bin/udevinfo $tmp_mnt/sbin/

    mkdir -p $tmp_mnt/etc/udev/rules.d
    # Create our own udev.conf
    echo "udev_root=\"/dev\"" > $tmp_mnt/etc/udev/udev.conf
    echo "udev_rules=\"/etc/udev/rules.d\"" >> $tmp_mnt/etc/udev/udev.conf
    # copy needed rules
    for rule in 05-udev-early.rules 50-udev-default.rules 59-dasd.rules 60-persistent-storage.rules 64-device-mapper.rules; do
	if [ -f /etc/udev/rules.d/$rule ]; then
	    cp /etc/udev/rules.d/$rule $tmp_mnt/etc/udev/rules.d
	fi
    done
    # copy helper scripts
    mkdir -p $tmp_mnt/lib/udev
    for script in /lib/udev/* ; do
	if [ -f "$script" ] ; then
	    cp_bin $script ${tmp_mnt}${script}
	fi
    done
    rm -f $tmp_mnt/lib/udev/mount.sh
    echo '#!/bin/sh' > $tmp_mnt/lib/udev/mount.sh
    echo 'exit 0' >> $tmp_mnt/lib/udev/mount.sh

    # udev *_id programs
    for prog in ata_id scsi_id scsi_tur usb_id vol_id dasd_id edd_id path_id; do
	cp_bin /sbin/$prog $tmp_mnt/sbin
    done

    # scsi_id config file
    cp /etc/scsi_id.config $tmp_mnt/etc/scsi_id.config

    # HBA firmware
    mkdir -p $tmp_mnt/lib/firmware
    for fw in /lib/firmware/ql*.bin /lib/firmware/aic94xx* ; do
	if [ -f "$fw" ] ; then
	    cp -a $fw $tmp_mnt/lib/firmware
	fi
    done

    if [ -n "$root_lvm" ] ; then
	features=(${features[@]} lvm)
	mkdir -p $tmp_mnt/etc/lvmtab.d
	cp_bin /sbin/{vgscan,vgchange} $tmp_mnt/sbin
	cp_bin /sbin/dmsetup $tmp_mnt/sbin
    fi

    if [ -n "$root_dm" ] ; then
	cp_bin /sbin/dmsetup $tmp_mnt/sbin
    fi

    if [ -n "$root_mpath" ] ; then
	features=(${features[@]} dm/mpath)
	cp_bin /sbin/multipath $tmp_mnt/sbin
	cp_bin /sbin/kpartx $tmp_mnt/sbin
	cp_bin /sbin/dmsetup $tmp_mnt/sbin
	cp_bin /sbin/mpath_id $tmp_mnt/sbin
	cp_bin /sbin/kpartx_id $tmp_mnt/sbin
	for pp in /sbin/mpath_prio_* ; do
	    cp_bin $pp $tmp_mnt/sbin
	done
	bindings_dir=/var/lib/multipath
	bindings_file=${bindings_dir}/bindings
	if [ -f /etc/multipath.conf ] ; then
	    cp -a /etc/multipath.conf $tmp_mnt/etc
	    f=$(sed -n '/^[ \t]*#.*/b;s/.*bindings_file *\"\?\([^" ]*\)\"\? */\1/p' /etc/multipath.conf)
	    if [ "$f" ] ; then
		bindings_file=$f
		bindings_dir=${bindings_file%/*}
	    fi
	fi
	[ -d ${tmp_mnt}${bindings_dir} ] || mkdir -p ${tmp_mnt}${bindings_dir}
	if [ -f $bindings_file ] ; then
	    cp -a $bindings_file ${tmp_mnt}${bindings_file}
	fi
	cp /etc/udev/rules.d/71-multipath.rules $tmp_mnt/etc/udev/rules.d
	cp /etc/udev/rules.d/72-multipath-compat.rules $tmp_mnt/etc/udev/rules.d
    fi

    if [ -n "$root_lvm2" ] ; then
	features=(${features[@]} dm/lvm2)
	mkdir -p $tmp_mnt/etc/lvm
	mkdir -p $tmp_mnt/var/lock/lvm
	cp_bin /sbin/{vgscan,vgchange,lvm} $tmp_mnt/sbin
	cp_bin /sbin/dmsetup $tmp_mnt/sbin
	cp_bin /bin/{sed,mkdir,mknod,ls} $tmp_mnt/bin
	# write a dump of the lvm configuration instead of copying lvm.conf if hosttags are in use
	if  grep -v '^#' /etc/lvm/lvm.conf | grep '\bhosttags[[:space:]]*=[[:space:]]*1\b' >/dev/null  ; then 
		/sbin/lvm dumpconfig > $tmp_mnt/etc/lvm/lvm.conf
	else
		cp -a /etc/lvm/lvm.conf $tmp_mnt/etc/lvm
	fi
    fi

    if [ -n "$root_evms" ] ; then
	features=(${features[@]} dm/evms2 evms2/$evms_policy)
	cp_bin /sbin/{evms_activate,dmsetup,evms} $tmp_mnt/sbin
	cp_bin /bin/{sed,mkdir,mknod,rm} $tmp_mnt/bin
	mkdir -p $tmp_mnt/mnt
	cp -a /etc/evms.conf $tmp_mnt/etc
	[ -d /lib/evms ] && evms_lib="/lib/evms"
	[ -d /lib64/evms ] && evms_lib="/lib64/evms"

	if [ "$evms_lib" ] ; then
	    mkdir -p ${tmp_mnt}${evms_lib}
	    SD=$(ls -A $evms_lib | tail -n 1)
	    (cd ${tmp_mnt}${evms_lib} && mkdir -p $SD)
	    cp_bin $evms_lib/$SD/* ${tmp_mnt}${evms_lib}/$SD
	    rm -f ${tmp_mnt}${evms_lib}/*/*{ext2,jfs,ogfs,reiser,swap,xfs}*so
	else
	    oops 7 "No EVMS modules found"
	fi
    fi

    if [ "$root_md" -o "$md_list" ] ; then
	need_mdadm=1
	if [ -f /etc/mdadm.conf ] ; then
	    cat /etc/mdadm.conf > $tmp_mnt/etc/mdadm.conf
	    md_mod_list="mdconf"
	else
	    echo "DEVICE partitions" > $tmp_mnt/etc/mdadm.conf
	    for md in $md_list ; do
		mdconf=$(eval echo \$md_conf_$md)
		md_mod=${mdconf#*level=}
		md_mod=${md_mod%% *}
		for mod in $md_mod_list ; do
		    if [ "$mod" == $"md_mod" ] ; then
			md_mod=
		    fi
		done
		if [ "$md_mod" ] ; then
		    if [ "$md_mod_list" ] ; then
			md_mod_list="$md_mod $md_mod_list"
		    else
			md_mod_list="$md_mod"
		    fi
		fi
		echo $mdconf >> $tmp_mnt/etc/mdadm.conf
	    done
	fi
	features=(${features[@]} md\($md_mod_list\))
    fi

    if [ -n "$need_mdadm" ] ; then
	features=(${features[@]} mdadm)
	cp_bin /sbin/mdadm $tmp_mnt/sbin
    fi

    if [ -n "$use_dhcp" ] ; then
	if [ -z "$use_ipconfig" -a -n "$macaddress" ] ; then
	    features=(${features[@]} dhcp\($macaddress\))
	else
	    features=(${features[@]} dhcp)
	fi
	cp_bin /sbin/dhcpcd $tmp_mnt/bin
	cp_bin /bin/kill $tmp_mnt/bin
	mkdir -p $tmp_mnt/var/lib/dhcpcd
	mkdir -p $tmp_mnt/var/run
    fi

    if [ -n "$use_ipconfig" ] ; then
	if [ -z "$use_dhcp" -a -n "$macaddress" ] ; then
	    features=(${features[@]} static\($macaddress\))
	else
	    features=(${features[@]} ipconfig)
	fi
	cp_bin /bin/ping $tmp_mnt/bin/ping
	cp_bin /sbin/ip $tmp_mnt/sbin/ip
    fi
  
    if [ "$rootfstype" = "ext2" ] ; then
	features=(${features[@]} fsck.ext2)
	cp_bin /sbin/fsck $tmp_mnt/bin
	cp_bin /sbin/fsck.ext2 $tmp_mnt/bin
    fi

    if [ "$rootfstype" = "ext3" ] ; then
	features=(${features[@]} fsck.ext3)
	cp_bin /sbin/fsck $tmp_mnt/bin
	cp_bin /sbin/fsck.ext3 $tmp_mnt/bin
    fi

    if [ "$rootfstype" = "reiserfs" ] ; then
	features=(${features[@]} fsck.reiserfs)
	cp_bin /sbin/fsck $tmp_mnt/bin
	cp_bin /sbin/fsck.reiserfs $tmp_mnt/bin
    fi

    if [ "$rootfstype" = "jfs" ] ; then
	features=(${features[@]} fsck.jfs)
	cp_bin /sbin/fsck $tmp_mnt/bin
	cp_bin /sbin/fsck.jfs $tmp_mnt/bin
    fi

    if [ "$rootfstype" = "xfs" ] ; then
	features=(${features[@]} fsck.xfs)
	cp_bin /sbin/fsck $tmp_mnt/bin
	cp_bin /sbin/fsck.xfs $tmp_mnt/bin
    fi

    if [ -n "$debug_mkinit" ]; then
	features=(${features[@]} debug)
	cp_bin /bin/ls $tmp_mnt/bin
    fi

    echo -ne "Shared libs:\t"
    # Copy all required shared libraries and the symlinks that
    # refer to them.
    lib_files=$(shared_object_files "${initrd_bins[@]}")
    if [ -n "$lib_files" ]; then
	for lib in $lib_files; do
	    [ -L $root_dir/$lib ] || echo -n "$lib "
	    ( cd ${root_dir:-/} ; cp -dp --parents $lib $tmp_mnt )
	done
	lib_files=
	# no symlinks, most point into the running system
	for i in `LANG=C LC_ALL=C file -b $tmp_mnt/{,usr/}{lib*/udev/,{,s}bin}/* | awk '/^ELF ..-bit/ { print $2 }' | sort -u`
	do
		case "$i" in
			32-bit)
				lib_dir=lib
				;;
			64-bit)
				lib_dir=lib64
				;;
		esac
		if [ $(uname -m) = "ia64" ] ; then
		    lib_dir=lib
		fi
		if [ ! -d $tmp_mnt/$lib_dir ] ; then
		    mkdir -p $tmp_mnt/$lib_dir
		fi
		lib_files="$lib_files `echo $root_dir/$lib_dir/libnss_files* $root_dir/$lib_dir/libgcc_s.so*`"
	done
	for lib in $lib_files ; do
	    if [ -f $lib ] ; then
		echo -n "${lib##$root_dir/} "
		cp -dp --parents $lib $tmp_mnt
	    fi
	done
	echo
    else
	echo "none"
    fi

    if [ -n "$lib_files" -a -n "$initrd_shell_dynamic" ]; then
	# If we have already have all dynamic libraries that
	# $initrd_shell_dynamic is using, and if $initrd_shell_dynamic
	# is smaller than $initrd_shell, we can save a little space
	# by using the dynamic version. The benefit is marginal, though.

	if smaller_file $initrd_shell_dynamic $initrd_shell ; then
	    for lib in $(shared_object_files $initrd_shell_dynamic) ; do
		case $lib_files in
		    *$lib*) ;;
		    *)	initrd_shell_dynamic=
		    	break ;;
		esac
	    done
	    if [ -n "$initrd_shell_dynamic" ]; then
		#echo " - Using dynamically linked $shebang"
		cp_bin $initrd_shell_dynamic $tmp_mnt$shebang
	    fi
	fi
    fi

    if [ -n "$lib_files" -a -n "$initrd_insmod_dynamic" ]; then
	# If we have already have all dynamic libraries that
	# $initrd_insmod_dynamic is using, and if $initrd_insmod_dynamic
	# is smaller than $initrd_insmod, we can save a little space
	# by using the dynamic version. The benefit is marginal, though.

	if smaller_file $initrd_insmod_dynamic $initrd_insmod ; then
	    for lib in $(shared_object_files $initrd_insmod_dynamic); do
		case $lib_files in
		    *$lib*) ;;
		    *)	initrd_insmod_dynamic=
		    	break ;;
		esac
	    done
	    if [ -n "$initrd_insmod_dynamic" ]; then
		#echo " - Using dynamically linked /sbin/insmod"
		cp_bin $initrd_insmod_dynamic $tmp_mnt/sbin/insmod
		cp_bin $initrd_modprobe_dynamic $tmp_mnt/sbin/modprobe
	    fi
	fi
    fi

    cat /dev/null > $linuxrc
    chmod 755 $linuxrc

    # Note that the in-place documents must be indented with tabs, not spaces.
    cat_linuxrc <<-EOF
	|#! $shebang
	|
	|export PATH=/sbin:/usr/sbin:/bin:/usr/bin
	|
	|die() {
	|    umount /proc
	|    umount /sys
	|    umount /dev
	|    exit \$1
	|}
	|
	|mount -t proc  proc  /proc
	|mount -t sysfs sysfs /sys
	|mount -t tmpfs -o mode=0755 udev /dev
	|
	|mknod -m 0666 /dev/tty     c 5 0
	|mknod -m 0600 /dev/console c 5 1
	|mknod -m 0666 /dev/ptmx    c 5 2
	|
	|exec < /dev/console > /dev/console 2>&1
	|
	|mknod -m 0640 /dev/mem c 1 1
	|mknod -m 0666 /dev/null c 1 3
	|mknod -m 0600 /dev/kmsg c 1 11
	|mknod -m 0660 /dev/snapshot c 10 231
	|mknod -m 0666 /dev/random c 1 8
	|mknod -m 0644 /dev/urandom c 1 9
	|mkdir -m 0755 /dev/pts
	|mkdir -m 1777 /dev/shm
	|ln -s /proc/self/fd /dev/fd
	|ln -s fd/0 /dev/stdin
	|ln -s fd/1 /dev/stdout
	|ln -s fd/2 /dev/stderr
	|echo "" > /proc/sys/kernel/hotplug
	|
	|kernel_cmdline=(\$@)
	|
	|# Default timeout is 30 seconds
	|udev_timeout=30
	|
	|for o in \$(cat /proc/cmdline); do
	|    if [ "\$z_arg" ] ; then
	|	init_args="\$init_args \$o"
	|	z_arg=
	|	continue
	|    fi
	|    case \$o in
	|    linuxrc=trace)
	|	echo -n "cmdline: "
	|	for arg in \$@; do
	|	    echo -n "\$arg "
	|	done
	|	echo ""
	|	set -x
	|	debug_linuxrc=1
	|	;;
	|    noresume)
	|	resume_mode=off
	|	;;
	|    sysrq=yes|sysrq=1)
	|	echo 1 > /proc/sys/kernel/sysrq
	|	;;
	|    -z)
	|	init_args="\$init_args \$o"
	|	z_arg=1
	|	;;
	|    -s)
	|	runlevel=s
	|	;;
	|    -b|emergency)
	|	init_args="\$init_args emergency"
	|	;;
	|    -a|auto)
	|	init_args="\$init_args auto"
	|	;;
	|    1|2|3|4|5|S|s|single)
	|	runlevel=\$o
	|	;;
	|    rw)
	|       read_write=1
	|       ;;
	|    ro)
	|       read_only=1
	|       ;;
	|    esac
	|done
	|
	|
	|for o in \$(cat /proc/cmdline); do
	|    case \$o in
	|    root=*)
	|	rootdev=\${o#root=}
	|	rootdev_cmdline=1
	|	;;
	|    rootfstype=*)
	|	rootfstype=\${o#rootfstype=}
	|	;;
	|    rootfsflags=*)
	|	rootflags=\${o#rootfsflags=}
	|	;;
	|    nfsroot=*)
	|	rootdev=\${o#nfsroot=}
	|	rootdev_cmdline=1
	|	;;
	|    resume=*)
	|	resumedev=\${o#resume=}
	|	;;
	|    journal=*)
	|	journaldev=\${o#journal=}
	|	;;
	|    mduuid=*)
	|	md_uuid=\${o#mduuid=}
	|	;;
	|    init=*)
	|	init=\${o#init=}
	|	;;
	|    udev_timeout=*)
	|	udev_timeout=\${o#udev_timeout=}
	|	;;
	|    rootflags=*)
	|	rootflags=\${o#rootflags=}
	|	;;
	|    dumpdev=*)
	|	dumpdev=\${o#dumpdev=}
	|	;;
	|    CRASH=*)
	|	kdump_kernel=\${o#CRASH=}
	|	;;
	|    evms=*)
	|	evms_policy=\${o#evms=}
	|	;;
	|    esac
	|done
	|
	|if [ -z "\$rootdev" ]; then
	|    rootdev=$rootdev
	|fi
	|if [ -z "\$dumpdev" ]; then
	|    dumpdev=$dumpdev
	|fi
	|if [ -z "\$evms_policy" ]; then
	|    evms_policy=$evms_policy
	|fi
	|# lilo strips off the /dev/prefix from device names!
	|case \$rootdev in
	|	/dev/disk/by-name/*)
	|	    rootdevid=\${rootdev#/dev/disk/by-name/}
	|	    rootdevid=\${rootdevid%-part*}
	|	    ;;
	|	/dev/md*)
	|	    md_dev=\$rootdev
	|	    md_minor=\${rootdev#/dev/md}
	|	    ;;
	|	/dev/*)
	|	    ;;
	|	LABEL=*)
	|	    label=\${rootdev#LABEL=}
	|	    echo "ENV{ID_FS_USAGE}==\"filesystem|other\", ENV{ID_FS_LABEL_SAFE}==\"\$label\", SYMLINK+=\"root\"" > /etc/udev/rules.d/99-mkinitrd-label.rules
	|	    rootdev=/dev/root
	|	    ;;
	|	UUID=*)
	|	    uuid=\${rootdev#UUID=}
	|	    echo "ENV{ID_FS_USAGE}==\"filesystem|other\", ENV{ID_FS_UUID}==\"\$uuid\", SYMLINK+=\"root\"" > /etc/udev/rules.d/99-mkinitrd-uuid.rules
	|	    rootdev=/dev/root
	|	    ;;
	|	[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])
	|	    maj=\$((0x0\$rootdev >> 8))
	|	    min=\$((0x0\$rootdev & 0xff))
	|	    echo "SUBSYSTEM==\"block\", SYSFS{dev}==\"\$maj:\$min\", SYMLINK+=\"root\"" > /etc/udev/rules.d/05-mkinitrd-lilo.rules
	|	    rootdev=/dev/root ;;
	|	[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])
	|	    maj=\$((0x\$rootdev >> 8))
	|	    min=\$((0x\$rootdev & 0xff))
	|	    echo "SUBSYSTEM==\"block\", SYSFS{dev}==\"\$maj:\$min\", SYMLINK+=\"root\"" > /etc/udev/rules.d/05-mkinitrd-lilo.rules
	|	    rootdev=/dev/root ;;
	|	0x[0-9a-fA-F][0-9a-fA-F]*)
	|	    maj=\$((\$rootdev >> 8))
	|	    min=\$((\$rootdev & 0xff))
	|	    echo "SUBSYSTEM==\"block\", SYSFS{dev}==\"\$maj:\$min\", SYMLINK+=\"root\"" > /etc/udev/rules.d/05-mkinitrd-lilo.rules
	|	    rootdev=/dev/root ;;
	|	*:*)
	|	    rootfstype="nfs"
	|	    ;;
	|	*)
	|	    rootdev=/dev/\$rootdev
	|	    ;;
	|esac
	|md_major=\$(sed -ne 's/\s*\([0-9]\+\)\s*md$/\1/p' /proc/devices)
	|if [ -n "\$md_major" -a "\$md_major" = "\$maj" ]; then
	|    md_minor="\$min"
	|    md_dev="/dev/md\$md_minor"
	|fi
	|
	|# Check whether kdump is enabled
	|if [ -e /proc/vmcore ] ; then
	|    kdump_kernel=1
	|fi
	|if [ "\$kdump_kernel" != "1" ] ; then
	|    kdump_kernel=
	|fi
	|# Do not attempt resuming when running under kdump
	|if [ "\$dumpdev" -a "\$kdump_kernel" ] ; then
	|    resume_mode=off
	|    unset resumedev
	|fi
	|
	|# Verify manual resume mode
	|if [ "\$resume_mode" != "off" -a -n "\$resumedev" ]; then
	|    if [ -w /sys/power/resume ]; then
	|	echo "Trying manual resume from \$resumedev"
	|	resume_mode=1
	|    else
	|	resumedev=
	|    fi
	|else
	|    resume_mode=
	|fi
	|
	|# Check for debugging
	|if [ -n "\$debug_linuxrc" ]; then
	|    echo "udev_log=\"debug\"" >> /etc/udev/udev.conf
	|else
	|    echo "udev_log=\"error\"" >> /etc/udev/udev.conf
	|fi
	|
	|# Set default for the journal device
	|if [ -z "\$journaldev" ]; then
	|    journaldev=$journaldev
	|fi
	EOF

    # Transfer the the block_driver function into the initrd
    type mkdevn | sed -e '1d' >> $linuxrc
    echo >> $linuxrc
    type devmajor | sed -e '1d' >> $linuxrc
    echo >> $linuxrc
    type devminor | sed -e '1d' >> $linuxrc
    echo >> $linuxrc
    type block_driver | sed -e '1d' >> $linuxrc
    echo >> $linuxrc
    type readlink | sed -e '1d' >> $linuxrc
    echo >> $linuxrc
    if [ -z "$use_static_binaries" ]; then
	type devnumber | sed -e '1d' >> $linuxrc
	echo >> $linuxrc
    fi

    # Start udev
    UDEVD_MAX_CHILDS=64
    UDEVD_MAX_CHILDS_RUNNING=16
    [ -f /etc/sysconfig/udev ] && . /etc/sysconfig/udev
    cat_linuxrc <<-EOF
	|
	|echo "Starting udevd"
	|UDEVD_MAX_CHILDS=${UDEVD_MAX_CHILDS}
	|UDEVD_MAX_CHILDS_RUNNING=${UDEVD_MAX_CHILDS_RUNNING}
	|export UDEVD_MAX_CHILDS UDEVD_MAX_CHILDS_RUNNING
	|/sbin/udevd --daemon
	|
	|echo "Creating devices"
	|/sbin/udevtrigger
	|/sbin/udevsettle --timeout=\$udev_timeout
	|
	EOF

    # FIXME: we should only load IDE modules if we need them for booting
    # Check for IDE modules
    if [ -z "$interface" ] ; then
	check_ide_modules $root_dir/lib/modules/$kernel_version
    fi

    resolved_modules="$(resolve_modules $kernel_version $modules)"

    # If a SCSI module is loaded, we will have a dependency on scsi_mod
    # for kernels which don't have this built in. In that case, assume
    # that the root file system is on a SCSI device, and also include
    # sd_mod.
    local have_scsi have_sd
    case "$resolved_modules" in
	*/scsi_mod.*)   have_scsi=1
			;;
	*/sd_mod.*)	have_sd=1
			;;
    esac
    if [ -n "$have_scsi" -a -z "$have_sd" ]; then
	modules="sd_mod $modules"
	# Re-evaluate module dependencies
	resolved_modules="$(resolve_modules $kernel_version $modules)"
    fi

    # The same reasoning goes for IDE modules
    local have_ide have_ide_disk
    case "$resolved_modules" in
	*/ide-core.*)   have_ide=1
			;;
	*/ide-disk.*)	have_ide_disk=1
			;;
    esac
    if [ -n "$have_ide" -a -z "$have_ide_disk" ]; then
	modules="ide-disk $modules"
	# Re-evaluate module dependencies
	resolved_modules="$(resolve_modules $kernel_version $modules)"
    fi

    if is_xen_kernel $kernel_version; then
	xenu_modules="$(resolve_modules $kernel_version $domu_modules)"
    fi

    # Copy all modules into the initrd
    for module in $resolved_modules $xenu_modules; do
	if [ ! -r $root_dir/$module ]; then
	    oops 9 "Module $module not found."
	    continue
	fi
	if ! ( cd ${root_dir:-/} ; cp -p --parents $module $tmp_mnt ) ; then
	    oops 6 "Failed to add module $module."
	    rm -rf $tmp_mnt
	    return
	fi
    done

    # Add modules which might be loaded via udev during booting
    uld_modules=
    for module in sd_mod osst st sr_mod sg ide-disk ide-scsi \
	          ide-cd ide-tape ide-floppy cdrom; do
	grep -qw $module $root_dir/lib/modules/$kernel_version/modules.dep \
	&& uld_modules="$uld_modules $module"
    done
    uld_modules="$(resolve_modules $kernel_version $uld_modules)"

    # Now copy the upper level driver modules
    for module in $uld_modules; do
	if [ ! -f $tmp_mnt/$module ]; then
	    if ! ( cd ${root_dir:-/} ; cp -p --parents $module $tmp_mnt ) ; then
		oops 6 "Failed to add module $module."
		rm -rf $tmp_mnt
		return
	    fi
	fi
    done

    # Filter modules into fs and non-fs (driver) modules.
    # We do this to avoid loading xfs when doing a resume: xfs had
    # (or still has) a bug that slows down resume a lot.
    # FIXME: get rid of this split crap again.
    for module in $resolved_modules; do
	if [ "$module" != "${module#*/kernel/fs/}" ]; then
	    fs_modules="$fs_modules $module"
	else
	    drv_modules="$drv_modules $module"
	fi
    done
    #fs_modules="$(echo "$resolved_modules" | grep -e '/kernel/fs/')"
    #drv_modules="$(echo "$resolved_modules" | grep -v -e '/kernel/fs/')"

    echo -ne "Driver modules:\t"
    initrd_is_using_modules=

    for modpath in $drv_modules; do
	module=${modpath##*/}
	module=${module%.ko}
	echo -n "${module} "
	cat_linuxrc <<-EOF
	|params=
	|for p in \$(cat /proc/cmdline) ; do
	|  case \$p in
	|    $module.*)
	|      params="\$params \${p#$module.}"
	|      ;;
	|  esac
	|done
	EOF

	case $module in
	    dasd_mod)
		# kernel cmdline dasd parameter is placed into the environment.
		# This is tricky. The only reliably way to check whether the
		# dasd parameter is set is to indeed check for it within the
		# initrd environment itself. Unfortunately the dasd module
		# refuses to load when the dasd parameter is empty, so we
		# need introduce an intermediate parameter which might be
		# set to empty entirely so as not to confuse the dasd module.
		#
		# This checks whether the dasd parameter is present
		cat_linuxrc <<-EOF
		|# check for DASD parameter in /proc/cmdline
		|for p in \$(cat /proc/cmdline) ; do
		|  case \$p in
		|    dasd=*)
		|      params="\$params \$p"
		|      dasd_params="\${p#dasd=}"
		|      ;;
		|  esac
		|done
		EOF
		;;
	    ide?core)
		# This checks whether an ide= parameter is present
		cat_linuxrc <<-EOF
		|# check for IDE parameter in /proc/cmdline
		|for p in \$(cat /proc/cmdline) ; do
		|  case \$p in
		|    ide=*)
		|      ide_params="\$ide_params \$p"
		|      ;;
		|    hd?=*)
		|      ide_params="\$ide_params \$p"
		|      ;;
		|  esac
		|done
		|if [ -n "\$ide_params" ]; then
		|  params="\$params options=\"\$ide_params\""
		|fi
		EOF
		;;
	    scsi_mod)
		# We may have SCSI parameters on the kernel command line,
		# but because scsi_mod is a module, those would be ignored.
		# Hack around this by scanning /proc/cmdline in linuxrc.

		cat_linuxrc <<-EOF
		|# check for SCSI parameters in /proc/cmdline
		|devflags=0
		|for p in \$(cat /proc/cmdline) ; do
		|  case \$p in
		|    scsi_mod.*)
		|	params="\$params \${p#scsi_mod.}"
		|	;;
		|    scsi_reportlun2=1)
		|	echo "scsi_reportlun2 compat: Use scsi_mod.default_dev_flags=0x20000 instead"
		|	devflags=\$((131072+\$devflags))
		|	;;
		|    scsi_noreportlun=1)
		|	echo "scsi_noreportlun compat: Use scsi_mod.default_dev_flags=0x40000 instead"
		|	devflags=\$((262144+\$devflags))
		|	;;
		|    scsi_sparselun=1)
		|	echo "scsi_sparselun compat: Use scsi_mod.default_dev_flags=0x40 instead"
		|	devflags=\$((64+\$devflags))
		|	;;
		|    scsi_largelun=1)
		|	echo "scsi_largelun compat: Use scsi_mod.default_dev_flags=0x200 instead"
		|	devflags=\$((512+\$devflags))
		|	;;
		|    llun_blklst=*)
		|	echo "llun_blklst is not supported any more"
		|	echo "use scsi_mod.dev_flags=VENDOR:MODEL:0x240[,V:M:0x240[,...]]"
		|	;;
		|    max_ghost_devices=*)
		|	echo "max_ghost_devices is not needed any more"
		|	;;
		|    max_sparseluns=*)
		|	echo "max_sparseluns not supported any more"
		|	echo "use scsi_mod.max_luns or enable the new REPORT_LUNS scsi"
		|	echo "scanning methods; try scsi_mod.default_dev_flags=0x20000"
		|	;;
		|    max_luns=*|max_report_luns=*|inq_timeout=*|dev_flags=*|default_dev_flags=*)
		|	echo "scsi_mod compat: Please use prefix: scsi_mod.\$p"
		|	params="\$params \$p"
		|      ;;
		|  esac
		|done
		|if [ \$devflags != 0 ]; then 
		|    params="default_dev_flags=\$devflags \$params"
		|fi
		EOF
		;;
	esac
	cat_linuxrc <<-EOF
	|echo "Loading $module"
	|modprobe $module \$params
	EOF

	initrd_is_using_modules=1
    done

    if [ -z "$initrd_is_using_modules" ]; then
	echo "none"
    else
	echo
    fi

    if  [ "$xenu_modules" ] && is_xen_kernel $kernel_version; then
	cat_linuxrc <<-EOF
	|caps="\$(cat /proc/xen/capabilities)"
	|if [ "\$caps" == "\${caps%control_d*}" ]; then
	EOF
	echo -ne "\nXen domU modules:\t"
	initrd_is_using_modules=
	for modpath in $xenu_modules; do
	    module=${modpath##*/}
	    module=${module%.ko}
	    echo -n "${module} "
	    cat_linuxrc <<-EOF
		|params=
		|for p in \$(cat /proc/cmdline) ; do
		|  case \$p in
		|    $module.*)
		|      params="\$params \${p#$module.}"
		|      ;;
		|  esac
		|done
		|echo "Loading $module"
		|modprobe $module \$params
		EOF

	    initrd_is_using_modules=1
	done

	if [ -z "$initrd_is_using_modules" ]; then
	    echo "none"
	else
	    echo
	fi
	cat_linuxrc <<-EOF
	|fi
	EOF
    fi

    if [ -n "$s390_dasd_disks" ]; then
	# We only need to activate DASDs manually if it
	# is not done via the kernel command line
	echo -e -n "DASDs:\t\t"
	cat_linuxrc <<-EOF
	|if test -z "\$dasd_params"; then
	|    echo -n "Activating DASDs:"
	EOF
	s390_dasd_disk_num=0
	for disk in $s390_dasd_disks; do
	    set -- $(IFS=":"; echo $disk)
	    use_diag=0
	    case "$2" in
		0)
		    echo -n " $1(ECKD)"
		    ;;
		1)
		    echo -n " $1(FBA)"
		    ;;
		2)
		    echo -n " $1(DIAG)"
		    use_diag=1
		    ;;
	    esac
	    cat_linuxrc <<-EOF
	|    echo -n " $disk"
	|    /sbin/dasd_configure $1 1 $use_diag
	EOF
	    s390_dasd_disk_num=$(( $s390_dasd_disk_num + 1 ))
	done
	echo ""
	cat_linuxrc <<-EOF
	|    echo " : done"
	|fi
	EOF
    fi

    if [ -n "$s390_zfcp_disks" ] && [ "$s390_zfcp_hbas" != "iSCSI" ] ; then
	echo -e -n "zfcp HBAs:\t"
	for hba in $s390_zfcp_hbas; do
	    echo -n "$hba "
	    cat_linuxrc <<-EOF
	|echo "Activating zfcp host $hba"
	|/sbin/zfcp_host_configure $hba 1
	EOF
	done
	echo

	echo -e "zfcp disks:\t"
	s390_zfcp_disk_num=0
	for disk in $s390_zfcp_disks; do
	    s390_zfcp_disk_num=$(( $s390_zfcp_disk_num + 1 ))
	    set -- $(IFS=":"; echo $disk)
	    echo -e "\t\t$1:$2:$3"
	    cat_linuxrc <<-EOF
	|echo "Activating zfcp disk $1:$2:$3"
	|/sbin/zfcp_disk_configure $1 $2 $3 1
	EOF
	done
    fi

    case "$(uname -m)" in
	s390|s390x)
	    if [ -z "$s390_zfcp_disks" -a -z "$s390_dasd_disks" ]; then
		echo ""
		echo "WARNING: No boot devices found."
		echo "Make sure to add 'dasd=<dasd-range>' to" \
		     "the kernel command line"
	    fi
	    ;;
    esac

    if [ -n "$interface" ] ; then
	cat_linuxrc <<-'EOF'
	|# configure interface
	|for o in $(cat /proc/cmdline); do
	|    case $o in
	|	eth[[:digit:]]=*)
	|	    tmp=${o#eth[[:digit:]]=}
	|	    interface=${o%=*}
	|	    macaddress=${tmp%,*}
	|	    ifmode=${tmp#*,}
	|	    ;;
	|	ibft=*)
	|	    ibft_mode=${o#ibft=}
	|	    ;;
	|    esac
	|done
	|if [ "$ifmode" = "dhcp" ] ; then
	|   dhcp_mode=1
	|fi
	|if [ "$ibft_mode" = "off" -a "$ifmode" = "ibft" ] ; then
	|   ibft_mode=
	|fi
	EOF
    fi

    if [ -n "$use_dhcp" ] ; then
	cat_linuxrc <<-'EOF'
	|# configure interface
	|for o in $(cat /proc/cmdline); do
	|  case $o in
	|    dhcp=*)
	|      if [ "${o#dhcp=}" ] && [ "${o#dhcp=}" = "off"] ; then
	|          dhcp_mode=
	|      else
	|          interface="${o#dhcp=}"
	|          dhcp_mode=1
	|      fi ;;
	|  esac
	|done
	|if [ -z "$dhcp_mode" ] ; then
	|   dhcp_mode=1
	|fi
	EOF
    fi

    if [ -n "$iscsi_root" ] ; then
	cat_linuxrc <<-EOF
	|# Check of iBFT settings
	|if [ "\$ibft_mode" != "off" ] && [ -x /sbin/fwparam_ibft ] ; then
	|    eval \$(/sbin/fwparam_ibft -b 2> /dev/null )
	|    if [ "\$iSCSI_INITIATOR_NAME" ] ; then
	|        echo "InitiatorName=\$iSCSI_INITIATOR_NAME" > /tmp/initiatorname.iscsi
	|    fi
	|    if [ "\$iSCSI_INITIATOR_HWADDR" ] ; then
	|      ibftspec=\$(/sbin/fwparam_ibft -b -i)
	|      iftype=\${ibftspec##*:}
	|      if [ "\$ibftspec" ] ; then
	|        if [ "\$iftype" = "dhcp" ] ; then
	|           dhcp_mode=1
	|           macaddress="\$iSCSI_INITIATOR_HWADDR"
	|        else
	|           ifspec="\$ibftspec"
	|        fi
	|      fi
	|    fi
	|fi
	|
	|for o in \$(cat /proc/cmdline); do
	|  case \$o in
	|    TargetAddress=*)
	|      if [ "\${o#TargetAddress=}" = "default" ] ; then
	|          unset iSCSI_TARGET_IPADDR
	|      else
	|          iscsiserver="\${o#TargetAddress=}"
	|      fi ;;
	|    TargetName=*)
	|      if [ "\${o#TargetName=}" = "default" ] ; then
	|          unset iSCSI_TARGET_NAME
	|      else
	|          iscsitarget="\${o#TargetName=}"
	|      fi ;;
	|    TargetPort=*)
	|      if [ "\${o#TargetPort=}" = "default" ] ; then
	|          unset iSCSI_TARGET_PORT
	|      else
	|          iscsiport="\${o#TargetPort=}"
	|      fi ;;
	|    InitiatorName=*)
	|      if [ "\${o#InitiatorName=}" = "default" ] ; then
	|          rm -f /tmp/initiatorname.iscsi
	|      else
	|          echo \${o#InitiatorName=} > /tmp/initiatorname.iscsi
	|      fi ;;
	|  esac
	|done
	|
	|if [ -f /tmp/initiatorname.iscsi ] ; then
	|    if [ -d /etc/iscsi ] ; then
	|        mv /tmp/initiatorname.iscsi /etc/iscsi
	|    else
	|        mv /tmp/initatorname.iscsi /etc
	|    fi
	|fi
	|if [ "\$iSCSI_TARGET_IPADDR" ] ; then
	|      iscsiserver="\$iSCSI_TARGET_IPADDR"
	|fi
	|if [ "\$iSCSI_TARGET_PORT" ] ; then
	|      iscsiport="\$iSCSI_TARGET_PORT"
	|fi
	|if [ "\$iSCSI_TARGET_NAME" ] ; then
	|      iscsitarget="\$iSCSI_TARGET_NAME"
	|fi
	EOF
    fi

    if [ -n "$use_dhcp" ] ; then
	cat_linuxrc <<-EOF
	|# run dhcp
	|if [ -n "\$dhcp_mode" ]; then
	|  # Fallback to hardcoded MAC address
	|  [ -z "\$macaddress" ] && macaddress="$macaddress"
	|  if [ "\$macaddress" ] ; then
	|    for dev in /sys/class/net/* ; do
	|      read tmpmac < \$dev/address
	|      if [ "\$tmpmac" == "\$macaddress" ] ; then
	|        interface=\${dev##*/}
	|        echo "using interface \$interface"
	|      fi
	|    done
	|  fi
	|  echo "running dhcpcd on interface \$interface"
	|  dhcpcd -R -Y -N -t 60 \$interface
	|  if [ -s /var/lib/dhcpcd/dhcpcd-\$interface.info ] ; then
	|    . /var/lib/dhcpcd/dhcpcd-\$interface.info
	|  else
	|    echo "no response from dhcp server."
	|  fi
	|  kill -9 \$(cat /var/run/dhcpcd-\$interface.pid)
	|  if [ -n "\$DNS" ]; then
	|    oifs="\$IFS"
	|    IFS=","
	|    for ns in \$DNS ; do
	|      echo "nameserver \$ns" >> /etc/resolv.conf
	|    done
	|    IFS="\$oifs"
	|    if [ -n "\$DOMAIN" ]; then
	|	echo "search \$DOMAIN" >> /etc/resolv.conf
	|    fi
	|    echo 'hosts: dns' > /etc/nsswitch.conf
	|  fi
	|fi
	EOF
    fi

    if [ -n "$interface" ] ; then
	case $interface in
	    ctc*)
		ccwdevs=$(s390_get_ctc_ccwdevs $interface)
	cat_linuxrc <<-EOF
	|# configure $interface
	|if [ -d /sys/bus/ccwgroup/drivers/ctc ]; then
	|  echo "$ccwdevs" > /sys/bus/ccwgroup/drivers/ctc/group
	|  # Wait for the device to appear
	|  i=100
	|  while [ "\$i" -gt 0 ]; do
	|    [ -d /sys/bus/ccwgroup/devices/${ccwdevs%%,*} ] && break
	|    i=\$(( \$i - 1 ))
	|  done
	|  if [ "\$i" -le 0 ] ; then
	|    echo "Interface $interface could not be setup, exiting to /bin/sh"
	|    cd /
	|    PATH=$PATH PS1='$ ' /bin/sh -i
	|  else
	|    echo 1 > /sys/bus/ccwgroup/devices/${ccwdevs%%,*}/online
	|  fi
	|fi
	EOF
	;;
	esac
    fi

    if [ -n "$use_ipconfig" ]; then
	[ "$interface" ] && ipinterface=$(get_ip_config $interface)
	cat_linuxrc <<-EOF
	|# configure interface
	|for o in \$(cat /proc/cmdline); do
	|  case \$o in
	|    ip=*)
	|      ifspec=\${o#ip=};;
	|  esac
	|done
	|if [ -z "\$ifspec" ]; then
	|  # Fallback to configured interface
	|  ifspec=$ipinterface
	|  # Fallback to hardcoded MAC address
	|  [ -z "\$macaddress" ] && macaddress="$macaddress"
	|  if [ "\$macaddress" ] ; then
	|    ifspec=\${ifspec%:*}
	|    interface=\${ifspec##*:}
	|    tmpspec=\${ifspec%:*}
	|    for dev in /sys/class/net/* ; do
	|      read tmpmac < \$dev/address
	|      if [ "\$tmpmac" == "\$macaddress" ] ; then
	|        interface=\${dev##*/}
	|        echo "using interface \$interface"
	|      fi
	|    done
	|    ifspec="\${tmpspec}:\${interface}:static"
	|  fi
	|fi
	|if [ -n "\$ifspec" ]; then
	|  echo "Setting up network \$ifspec"
	|  /bin/ipconfig.sh \$ifspec
	|fi
	EOF
    fi

    if [ -n "$iscsi_root" ] ; then
	if [ -d /sys/class/iscsi_session/$iscsi_root ] ; then
	    iscsi_tgtname=$(cat /sys/class/iscsi_session/${iscsi_root}/targetname)
	    iscsi_tgtaddr=$(cat /sys/class/iscsi_connection/connection${iscsi_root#session}:0/address)
	fi
	cat_linuxrc <<-EOF
	|iscsi_mark_root_nodes()
	|{
	|    local iscsi_tgts
	|
	|    if [ -z "\$iscsitarget" ] ; then
	|        iscsi_tgts=\$(/sbin/iscsiadm -m node | sed -n "s/.*\$iscsiserver:\$iscsiport,.* \(iqn.*\)/\1/p")
	|    else
	|        iscsi_tgts="\$iscsitarget"
	|    fi
	|
	|    for tgt in \$iscsi_tgts ; do
	|        echo "Setup iSCSI target \$tgt"
	|        /sbin/iscsiadm -m node -p \$iscsiserver:\$iscsiport -T \$tgt -o update -n node.conn[0].startup -v automatic
	|    done
	|}
	|
	|iscsi_discover_nodes()
	|{
	|    echo -n "Starting discovery on \${iscsiserver},\${iscsiport}: "
	|    if /sbin/iscsiadm -m discovery -t st -p \${iscsiserver}:\${iscsiport} 2> /dev/null ; then
	|        echo "ok."
	|    else
	|        echo "failed."
	|    fi
	|}
	|
	|echo "Starting iSCSI daemon"
	|/sbin/iscsid
	|usleep 5000000
	|
	|[ -z "\$iscsiserver" ] && iscsiserver=$iscsi_tgtaddr
	|[ -z "\$iscsiport" ] && iscsiport=3260
	|[ -z "\$iscsitarget" ] && iscsitarget=$iscsi_tgtname
	|
	|if [ "\$iscsiserver" -a "\$iscsiport" ] ; then
	|    if [ "\$iscsitarget" ] ; then
	|        if ! /sbin/iscsiadm -m node -p \$iscsiserver:\$iscsiport -T \$iscsitarget > /dev/null 2>&1 ; then
	|            do_iscsi_discovery=yes
	|        fi
	|    else
	|        if ! /sbin/iscsiadm -m node -p \$iscsiserver:\$iscsiport > /dev/null 2>&1 ; then
	|            do_iscsi_discovery=yes
	|        fi
	|    fi
	|    if [ "\$do_iscsi_discovery" ] ; then
	|        iscsi_discover_nodes
	|    fi
	|    iscsi_mark_root_nodes
	|fi
	|echo "Logging in to all nodes"
	|/sbin/iscsiadm -m node -L automatic
	|
	EOF
    fi

    if [ "$rootfstype" = "nfs" ]; then
	cat_linuxrc <<-'EOF'
	|if [ -z "$rootdev_cmdline" ]; then
	|  case "$ROOTPATH" in
	|    "") ;;
	|    *:*)
	|	rootfstype="nfs"
	|	rootdev="$ROOTPATH" ;;
	|    *)
	|	if [ -n "$DHCPSIADDR" ]; then
	|	    rootdev="$DHCPSIADDR:$ROOTPATH"
	|	    rootfstype="nfs"
	|	elif [ -n "$DHCPSNAME" ]; then
	|	    rootdev="$DHCPSNAME:$ROOTPATH"
	|	    rootfstype="nfs"
	|	fi ;;
	|   esac
	|   if [ -z "$rootdev" ]; then
	|	echo "no local root= kernel option given and no root" \
	|	     "server set by the dhcp server."
	|	echo 256 > /proc/sys/kernel/real-root-dev
	|	die 0
	|   fi
	|fi
	EOF
    fi

    if [ -n "$root_mpath" -o -n "$root_lvm2" -o -n "$root_evms" ]; then
	cat_linuxrc <<-'EOF'
	|echo -n "Waiting for /dev/mapper/control to appear: "
	|for i in 1 2 3 4 5; do
	|    [ -e /dev/mapper/control ] && break
	|    sleep 1
	|    echo -n "."
	|done
	|if [ -e /dev/mapper/control ]; then
	|    echo " ok"
	|    dm_major=$(sed -n 's/\(.*\) device-mapper/\1/p' /proc/devices)
	|else
	|    echo " failed"
	|fi
	EOF
    fi

    cat_linuxrc <<-'EOF'
	|
	|# Waiting for a device to appear
	|# device node will be created by udev
	|udev_check_for_device() {
	|    local root
	|    local retval=1
	|    local timeout=$udev_timeout
	|    local devn
	|    local major
	|    root=$1
	|    if [ -n "$root" ]; then
	|	echo -n "Waiting for device $root to appear: "
	|	while [ $timeout -gt 0 ]; do
	EOF
    if [ -n "$root_mpath" ] ; then
	cat_linuxrc <<-'EOF'
	|	    if [ -e $root ]; then
	|	        devn=$(devnumber $root)
	|	        major=$(devmajor $devn)
	|		if [ -z "$dm_major" ] || [ "$major" == "$dm_major" ] || [ "$major" == "$md_major" ] ; then
	|		    retval=0
	|		    echo " ok"
	|		    break;
	|		fi
	|	    fi
	|	    echo -n "!"
	|	    [ -x /sbin/vgchange ] && /sbin/vgchange -a n
	|	    [ -z "$dm_major" ] || multipath -v0
	|           /sbin/udevsettle --timeout=$udev_timeout
	|	    sleep 1
	EOF
    else
	cat_linuxrc <<-'EOF'
	|	    if [ -e $root ]; then
	|		echo " ok"
	|		retval=0
	|		break;
	|	    fi
	|	    sleep 1
	EOF
    fi

    if [ -n "$root_lvm2" ] ; then
	cat_linuxrc <<-'EOF'
	|	    /sbin/vgscan
	|	    /sbin/vgchange -a y $vgname
	|           /sbin/udevsettle --timeout=$udev_timeout
	EOF
    fi

    cat_linuxrc <<-'EOF'
	|	    echo -n "."
	|	    timeout=$(( $timeout - 1 ))
	|	done
	|    fi
	|    if [ -x /sbin/vgchange ] && [ -x /sbin/multipath ] && [ "$dm_major" ] ; then
	|        echo "Resetting LVM for multipath"
	|        vgchange -a n
	|        multipath -v 0
	|        /sbin/udevsettle --timeout=$udev_timeout
	|        vgscan
	|        vgchange -a y $vgname
	|        /sbin/udevsettle --timeout=$udev_timeout
	|    fi
	|    return $retval;
	|}
	|
	|udev_discover_resume() {
	|    local resume
	|    # Waits for the resume device to appear
	|    if [ -n "$resume_mode" ]; then
	|	if [ -e $resumedev ] ; then
	|	    # Try major:minor number of the device node
	|	    devn=$(devnumber $resumedev)
	|	    major=$(devmajor $devn)
	|	    minor=$(devminor $devn)
	|	    devn=
	|       fi
	|       if [ -n "$major" -a -n "$minor" ]; then
	|	    echo "$major:$minor" > /sys/power/resume
	|	    major=
	|	    minor=
	|	else
	|	    echo "resume device $resumedev not found (ignoring)"
	|       fi
	|    fi
	|}
	|
	|udev_discover_dump() {
	|    local root
	|    case "$dumpdev" in
	|	*:*) root= ;;
	|	/dev/nfs) root= ;;
	|	/dev/*)	root=${rootdev#/dev/} ;;
	|    esac
	|    if [ -z "$root" ]; then
	|	return 0
	|    fi
	|    if udev_check_for_device $dumpdev  ; then
	|	# Get major:minor number of the device node
	|	devn=$(devnumber $rootdev)
	|	major=$(devmajor $devn)
	|	minor=$(devminor $devn)
	|    fi
	|    if [ -n "$devn" ]; then
	|	echo "rootfs: major=$major minor=$minor" \
	|	    "devn=$devn"
	|	echo $devn > /proc/sys/kernel/real-root-dev
	|	return 0
	|    else
	|	return 1
	|    fi
	|}
	|
	|udev_discover_root() {
	|    local root
	|    case "$rootdev" in
	|	*:*) root= ;;
	|	/dev/nfs) root= ;;
	|	/dev/*)	root=${rootdev#/dev/} ;;
	|    esac
	|    if [ -z "$root" ]; then
	|	return 0
	|    fi
	|    if udev_check_for_device $rootdev  ; then
	|	# Get major:minor number of the device node
	|	devn=$(devnumber $rootdev)
	|	major=$(devmajor $devn)
	|	minor=$(devminor $devn)
	|    fi
	|    if [ -n "$devn" ]; then
	|	echo "rootfs: major=$major minor=$minor" \
	|	    "devn=$devn"
	|	echo $devn > /proc/sys/kernel/real-root-dev
	|	return 0
	|    else
	|	return 1
	|    fi
	|}
	|
	|/sbin/udevsettle --timeout=$udev_timeout
	|
	EOF

    # Load fs modules _after_ resume
    echo -ne "Filesystem modules:\t"
    initrd_is_using_modules=
    for modpath in $fs_modules; do
	module=${modpath##*/}
	module=${module%.ko}
	echo -n "$module "
	cat_linuxrc <<-EOF
	|params=
	|for p in \$(cat /proc/cmdline) ; do
	|  case \$p in
	|    $module.*)
	|      params="\$params \${p#$module.}"
	|      ;;
	|  esac
	|done
	EOF

	cat_linuxrc <<-EOF
	|echo "Loading ${module#/lib/modules/$kernel_version/}"
	|modprobe $module
	EOF
	initrd_is_using_modules=1
    done
    echo

    # And run depmod to ensure proper loading
    if [ "$sysmap" ] ; then
	map="$sysmap"
    else
	map=$root_dir/boot/System.map-$kernel_version
    fi
    if [ ! -f $map ]; then
	map=$root_dir/boot/System.map
    fi
    if [ ! -f $map ]; then
	oops 9 "Could not find map $map, please specify a correct file with -M."
	rm -rf $tmp_mnt
	return
    fi

    ( cd $tmp_mnt; /sbin/depmod -b $tmp_mnt -e -F $map $kernel_version )

    if [ -n "$root_mpath" ] ; then
	cat_linuxrc <<-EOF
	|# check for multipath parameter in /proc/cmdline
	|for o in \$(cat /proc/cmdline) ; do
	|  case \$o in
	|    multipath=*)
	|      mpath_status=\${o#multipath=};;
	|  esac
	|done
	|if [ "\$mpath_status" != "off" ] ; then
	|  # Rescan for multipath
	|  echo -n "Setup multipath devices: "
	|  /sbin/multipath -v0
	|  /sbin/udevsettle --timeout=\$udev_timeout
	|  echo 'ok.'
	|else
	|  # Reset as we're not using multipath
	|  dm_major=
	|fi
	EOF
    else
	cat_linuxrc <<-EOF
	|# No multipath support
	|dm_major=0
	EOF
    fi

    if [ -n "$need_raidstart" ]; then
	features=(${features[@]} raidstart)
	cat_linuxrc <<-EOF
	|echo "raidstart ..."
	|raidstart --all
	|echo "done..."
	EOF
    fi

    if [ -n "$need_mdadm" ]; then
	cat_linuxrc <<-EOF
	|
	|md_major=$(sed -n 's/ *\(.*\) md$/\1/p' /proc/devices)
	|
	|if [ -f /etc/mdadm.conf ] ; then
	|    mdconf="-Ac /etc/mdadm.conf"
	|    [ -z "\$md_dev" ] && md_dev="--scan"
	|fi
	|
	|if [ -n "\$md_uuid" ] ; then
	|    mdarg="--uuid=\$md_uuid"
	|elif [ -n "$md_uuid" ] ; then
	|    mdarg="\$mdarg --uuid=$md_uuid"
	|fi
	|if [ -n "\$md_minor" ] ; then
	|    mdarg="\$mdarg --super-minor=\$md_minor"
	|    md_dev="/dev/md\$md_minor"
	|elif [ -z "\$md_minor" -a -n "$md_minor" ] ; then
	|    mdarg="\$mdarg --super-minor=$md_minor"
	|fi
	|
	|case \$resumedev in
	|    /dev/md*)
	|        echo 1 > /sys/module/md_mod/parameters/start_ro
	|        resumeminor="\${resumedev#/dev/md}"
	|        mdadm -Ac partitions -m \$resumeminor --auto=md \$resumedev
	|        ;;
	|esac
	|
	|if [ "\$md_dev" ] ; then
	|    /sbin/mdadm \$mdconf --auto=md \$md_dev || /sbin/mdadm -Ac partitions \$mdarg --auto=md \$md_dev
	|fi
	EOF
    fi

    if [ -z "$is_kdump" ] && [ -n "$need_mdadm" ] ; then
	cat_linuxrc <<-'EOF'
	|if [ -z "$kdump_kernel" ]; then
	|  # Wait for udev to settle
	|  /sbin/udevsettle --timeout=$udev_timeout
	|  # Check for a resume device
	|  udev_discover_resume
	|fi
	EOF
    fi

    if [ -n "$need_mdadm" ]; then
	cat_linuxrc <<-EOF
	|if [ -n "\$resume_minor" ] ; then
	|    # Stop all arrays
	|    /sbin/mdadm --stop
	|    # Switch md back to read-write mode
	|    if [ -f /sys/module/md_mod/parameters/start_ro ]; then
	|        # maybe should switch all arrays to rw/ but not really necessary
	|        echo 0 > /sys/module/md_mod/parameters/start_ro
	|    fi
	|
	|    # And restart them again
	|    /sbin/mdadm \$mdarg --auto=md \$md_dev
	|    /sbin/udevsettle --timeout=\$udev_timeout
	|fi
	EOF
    fi

    if [ -n "$root_lvm" ] ; then
	# Name of the volume containing the root filesystem
        local vg_root=${rootdev#/dev/}
        vg_root=${vg_root%%/*}

	cat_linuxrc <<-EOF
	|#need space for lvm data
	|mount -tramfs none /etc/lvmtab.d
	|vgscan
	|for o in \$(cat /proc/cmdline); do
	|  case \$o in
	|    root=/dev/*)
	|	set -- \$(IFS=/ ; echo \$o)
	|	vg_root=\$3
	|	;;
	|  esac
	|done
	|if [ -z "\$vg_root" ]; then
	|  vg_root=$vg_root
	|fi
	|
	|vgchange -a y \$vg_root
	|umount /etc/lvmtab.d
	EOF
    fi

    if [ -n "$root_lvm2" ] ; then
	cat_linuxrc <<-EOF
	|
	|for o in \$(cat /proc/cmdline); do
	|  case \$o in
	|    root=/dev/disk/by-*/*)
	|       vg_root=
	|       ;;
	|    root=/dev/mapper/*)
	|       vg_name=\${o##root=/dev/mapper/}
	|       vg_root=\${vg_name%%-*}
	|       ;;
	|    root=/dev/*)
	|       set -- \$(IFS=/ ; echo \$o)
	|       if [ "\$#" = "3" ] && [ "\$2" != "cciss" ] ; then
	|           vg_root=\$2
	|       fi
	|       ;;
	|  esac
	|done
	|if [ -z "\$vg_root" ]; then
	|  vg_root=$vg_root
	|fi
	|
	|vgchange -a y \$vg_root
	EOF
    fi

    if [ -n "$root_evms" ] ; then
	cat_linuxrc <<-'EOF'
	|get_evms_devices() {
	|    local evms_cmd
	|    local evms_reg
	|    local evms_cont
	|    local evms_seg
	|    local evms_dsk
	|
	|    if [ ! -x /sbin/evms ]; then
	|	return 1
	|    fi
	|
	|    if [ -n "$1" ]; then
	|	evms_cmd="q:r,v=$1"
	|
	|	while read a b c d; do
	|	    if [ "$a $b" = "Region Name:" ]; then
	|		evms_reg="$evms_reg $c"
	|	    fi
	|	done < <( echo "$evms_cmd" | /sbin/evms -s -b )
	|    fi
	|
	|    : EVMS Region: $evms_reg
	|
	|    for reg in $evms_reg; do
	|	evms_cmd="q:c,r=$reg"
	|	
	|	while read a b c d; do
	|	    if [ "$a $b" = "Container Name:" ]; then
	|		evms_cont="$evms_cont $c"
	|	    fi
	|	done < <(echo "$evms_cmd" | /sbin/evms -s -b )
	|    done
	|
	|    : EVMS Container: $evms_cont
	|
	|    for cont in $evms_cont; do
	|	evms_cmd="q:s,c=$cont"
	|	
	|	while read a b c d; do
	|	    if [ "$a $b" = "Segment Name:" ]; then
	|		if [ "$evms_seg" ] ; then
	|		    for seg in $evms_seg; do
	|			if [ "$c" = "$seg" ] ; then
	|			    unset c
	|			    break;
	|			fi
	|		    done
	|		    if [ "$c" ] ; then
	|			evms_seg="$evms_seg $c"
	|		    fi
	|		else
	|		    evms_seg="$c"
	|		fi
	|	    fi
	|	done < <(echo "$evms_cmd" | /sbin/evms -s -b )
	|    done
	|
	|    echo "$evms_seg"
	|}
	|
	|create_evms_save_table() {
	|    local tblfile=$1
	|    local num=0
	|    shift
	|
	|    rm -f $tblfile
	|    
	|    dmdevs=$(dmsetup info -c --noheadings -o name | sed -e 's.|./.g')
	|    for d in $dmdevs ; do
	|	# Check if device exists (ie is a partition)
	|	if [ ! -e /dev/$d ] ; then
	|	    unset d
	|	fi
	|	# Filter out devices used by EVMS region
	|	for e in $*; do
	|	    if [ "$d" = "$e" ] ; then
	|		unset d
	|	    fi
	|	done
	|	# Create temp table
	|	if [ "$d" ] ; then
	|	    echo $(( num * 100 )) 100 linear /dev/$d 0 >> $tblfile
	|	    num=$(( num + 1 ))
	|	fi
	|    done
	|    echo $num
	|}
	|
	|/sbin/evms_activate
	|if [ "$evms_policy" != "disk" ] ; then
	|    evmsdevs=$(get_evms_devices $rootdev)
	|    evmsnum=$(create_evms_save_table /tmp/evms_save_table $evmsdevs)
	|else
	|    evmsnum=0
	|fi
	|if [ $evmsnum -gt 0 ] ; then
	|    /sbin/dmsetup remove_all
	|    /sbin/dmsetup create evms_save < /tmp/evms_save_table
	|    /sbin/evms_activate
	|    /sbin/dmsetup remove evms_save
	|fi
	EOF
    fi

    if [ "$is_kdump" ] ; then
	cat_linuxrc <<-'EOF'
	|# And now for the real thing
	|if [ "$kdump_kernel" ] && [ "$dumpdev" ] && udev_discover_dump ; then
	|    echo "ok, dumping to $dumpdev"
	|    cp --sparse=always /proc/vmcore $dumpdev
	|    if [ $? -eq 0 ] ; then
	|        echo "Dump saved. Rebooting."
	|        /sbin/reboot -d -f
	|    fi
	|    echo "Dumping failed, continue with booting"
	|fi
	EOF
    fi

    if [ -z "$need_mdadm" ] ; then
	cat_linuxrc <<-'EOF'
	|# Wait for udev to settle
	|/sbin/udevsettle --timeout=$udev_timeout
	|# Check for a resume device
	|udev_discover_resume
	EOF
    fi

    cat_linuxrc <<-'EOF'
	|# And now for the real thing
	|if ! udev_discover_root ; then
	|    echo "not found -- exiting to /bin/sh"
	|    cd /
	|    PATH=$PATH PS1='$ ' /bin/sh -i
	|fi
	EOF

    if [ -n "$root_lerfs" ] ; then
        rootName=${rootdev#"/dev/mapper/"}
        cat_linuxrc <<-EOF
	|# Try to unlock the root filesystem
	|clear
	|echo
	|while [ \$((c)) -lt 3 ] ; do
	|    # First we try to open using /tmp/luks.key
	|    if [ -r /tmp/luks.key ] ; then
	|        cryptsetup --key-file /tmp/luks.key luksOpen \$rootdev $rootName 2> /dev/null
	|        [ "\$?" = 0 ] && break
	|    fi
	|    echo
	|    echo -n "Enter passphrase: "
	|    read -s ssopass
	|    echo
	|    echo -n \$ssopass | cryptsetup luksOpen \$rootdev $rootName 2> /dev/null
	|    if [ "\$?" = 0 ]; then
	|        break
	|    else
	|        echo "Try again..."
	|        echo
	|    fi
	|    c=\$((c + 1))
	|done
	|if [ \$((c)) -ge 3 ]; then
	|    echo "Too many failures..."
	|    die 1
	|fi
	|rootdev=$rootdev
	EOF

        count=0
        while [ $count -lt $numLuks ] ; do
            cat_linuxrc <<-EOF
	|#open the LUKS encrypted file system ${cryptdev[$count]}
	|echo
	|echo "Opening the LUKS encrypted file system ${cryptdev[$count]}"
	|
	|#first we try to open the file system using the /tmp/luks.key
	|retval=1
	|if [ -r /tmp/luks.key ] ; then
	|    cryptsetup --key-file /tmp/luks.key luksOpen ${cryptdev[$count]} ${dmname[$count]} 2> /dev/null
	|    retval=\$?
	|fi
	|if [ "\$retval" != 0 ]; then
	|    # Now we try the ssopass
	|    echo -n \$ssopass | cryptsetup luksOpen ${cryptdev[$count]} ${dmname[$count]} 2> /dev/null
	|    retval=\$?
	|fi
	|if [ "\$retval" != 0 ]; then
	|    c=0
	|    while [ \$((c)) -lt 3 ] ; do
	|        echo -n "Enter passphrase for ${cryptdev[$count]}: "
	|        read -s pass
	|        echo
	|        echo -n \$pass | cryptsetup luksOpen ${cryptdev[$count]} ${dmname[$count]} 2> /dev/null
	|        if [ "\$?" = 0 ]; then
	|            break
	|        else
	|            echo "Try again..."
	|            echo
	|        fi
	|        c=\$((c + 1))
	|    done
	|    if [ \$((c)) -ge 3 ]; then
	|        echo "Too many failures...Device not opened"
	|    fi
	|fi
	EOF
            count=$(($count + 1))
        done

        cat_linuxrc <<-EOF
	|
	|#release the pass phrases
	|ssopass=3xUxj04EbEl
	|pass=DSwESCNsEb
	|unset ssopass
	|unset pass
	|
	EOF
    fi

    cat_linuxrc <<-'EOF'
	|if [ -z "$rootfstype" ]; then
	|    rootfstype=$(/sbin/vol_id -t $rootdev)
	|    [ $? -ne 0 ] && rootfstype=
	|    [ -n "$rootfstype" ] && [ "$rootfstype" = "unknown" ] && $rootfstype=
	|fi
	|
	|# check filesystem if possible
	|if [ -z "$rootfstype" ]; then
	|    echo "invalid root filesystem -- exiting to /bin/sh"
	|    cd /
	|    PATH=$PATH PS1='$ ' /bin/sh -i
	|elif [ -x /bin/fsck.${rootfstype} ]; then
	|    # fsck is unhappy without it
	|    echo "$rootdev / $rootfstype defaults 1 1" > /etc/fstab
	|    fsckopts="-V -a"
	|    # Check external journal for reiserfs
	|    [ "$rootfstype" = "reiserfs" -a -n "$journaldev" ] && fsckopts="-j $journaldev $fsckopts"
	|    fsck -t $rootfstype $fsckopts $rootdev
	|    # Return the fsck status
	|    ROOTFS_FSCK=$?
	|    export ROOTFS_FSCK
	|    ROOTFS_FSTYPE=$rootfstype
	|    export ROOTFS_FSTYPE
	|    if [ $ROOTFS_FSCK -gt 1 -a $ROOTFS_FSCK -lt 4 ]; then
	|        # reboot needed
	|        echo "fsck succeeded, but reboot is required."
	|        echo "Rebooting system."
	|        /sbin/reboot -d -f
	|    elif [ $ROOTFS_FSCK -gt 3 ] ; then
	|        echo "fsck failed. Mounting root device read-only."
	|        read_write=
	|    else
	|        if [ "$read_only" ]; then
	|            echo "fsck succeeded. Mounting root device read-only."
	|            read_write=
	|        else
	|            echo "fsck succeeded. Mounting root device read-write."
	|            read_write=1
	|        fi
	|    fi
	|fi
	EOF

    cat_linuxrc <<-'EOF'
	|opt="-o ro"
	|[ -n "$read_write" ] && opt="-o rw"
	|[ "$rootfstype" = "nfs" ] && opt="${opt},nolock"
	|
	|# tell kernel root is /dev/ram0, prevents remount after initrd
	|echo 256 > /proc/sys/kernel/real-root-dev
	|# mount the actual root device below /root
	|echo "Mounting root $rootdev"
	|# check external journal
	|[ "$rootfstype" = "xfs" -a -n "$journaldev" ] && opt="${opt},logdev=$journaldev"
	|[ "$rootfstype" = "reiserfs" -a -n "$journaldev" ] && opt="${opt},jdev=$journaldev"
	|[ -n "$rootflags" ] && opt="${opt},$rootflags"
	|[ -n "$rootfstype" ] && opt="${opt} -t $rootfstype"
	|if [ -x /bin/nfsmount -a "$rootfstype" = "nfs" ]; then
	|    nfsmount $rootdev /root || die 1
	|else
	|    mount $opt $rootdev /root || die 1
	|fi
	|# Create iSCSI target node file
	|if [ "$do_iscsi_discovery" ] ; then
    	|    if [ ! -e /root/etc/iscsi/nodes/$iscsitarget/${iscsiserver},${iscsiport} ] ; then
	|	echo Setting up new iSCSI target node in root FS
	|	cp /etc/iscsi/nodes/$iscsitarget/${iscsiserver},${iscsiport} /root/etc/iscsi/nodes/$iscsitarget/${iscsiserver},${iscsiport}
    	|    fi
	|fi
	|# End Create config file for iscsi
	|# Look for an init binary on the root filesystem
	|if [ -n "$init" ] ; then
	|    if [ ! -f "/root$init" ]; then
	|        init=
	|    fi
	|fi
	|
	|if [ -z "$init" ] ; then
	|    for i in /sbin/init /etc/init /bin/init /bin/sh ; do
	|        if [ ! -f "/root$i" ] ; then continue ; fi
	|        init="$i"
	|        break
	|    done
	|fi
	|
	|if [ -z "$init" ] ; then
	|    echo "No init found. Try passing init= option to the kernel."
	|    die 1
	|fi
	|
	|# Parse root mount options
	|if [ -f /root/etc/fstab ] ; then
	|    fsoptions=$(sed -e'/^[ 	]*#/d' /root/etc/fstab | while read d m f o r; do if [ "$m" == "/" ] ; then echo $o; fi; done)
	|    set -- $(IFS=,; echo $fsoptions)
	|    fsoptions=
	|    while [ "$1" ] ; do
	|        case $1 in
	|        *quota)
	|            if [ "$rootfstype" != "xfs" ] ; then
	|                if [ "$fsoptions" ] ; then
	|                    fsoptions="$fsoptions,$1"
	|                else
	|                    fsoptions="$1"
	|                fi
	|             fi
	|             ;;
	|        defaults) ;;
	|        *)
	|            if [ "$fsoptions" ] ; then
	|                fsoptions="$fsoptions,$1"
	|            else
	|                fsoptions="$1"
	|            fi
	|            ;;
	|        esac
	|        shift
	|    done
	|    if [ "$fsoptions" ] ; then
	|        mount -o remount,$fsoptions $rootdev /root
	|    fi
	|fi
	|
	|# Create framebuffer devices
	|if [ -f /proc/fb ]; then
	|    while read fbnum fbtype; do
	|        if [ $(($fbnum < 32)) ] ; then
	|            [ -c /dev/fb$fbnum ] || mknod -m 0660 /dev/fb$fbnum c 29 $fbnum
	|        fi
	|    done < /proc/fb
	|fi
	|
	|/bin/mount --move /dev /root/dev
	|
	|# Call vendor-specific init script
	|if [ -x /vendor_init.sh ] ; then
	|    /vendor_init.sh
	|fi
	|
	|# kill udevd, we will run the one from the real root
	|kill $(pidof udevd)
	|
	|# kill iscsid, will be restarted from the real root
	|iscsi_pid=$(pidof iscsid)
	|[ "$iscsi_pid" ] && kill -KILL $iscsi_pid
	|
	|# ready to leave
	|cd /root
	|umount /proc
	|umount /sys
	|
	|# Export root fs information
	|ROOTFS_BLKDEV="$rootdev"
	|export ROOTFS_BLKDEV
	|
	|exec /bin/run-init -c ./dev/console /root $init $init_args $runlevel
	|echo could not exec run-init!
	|die 0
	EOF

    [ ${#features[@]} -gt 0 ] \
	&& echo -e "Including:\t${features[@]}"

    splash_bin=
    [ -x /sbin/splash.bin ] && splash_bin=/sbin/splash.bin
    [ -x /bin/splash ] && splash_bin=/bin/splash
    splash_image=
    if [ -n "$splashsizes" -a -n "$splash_bin" ]; then
	if [ -f /etc/sysconfig/bootsplash ]; then
	    . /etc/sysconfig/bootsplash
	fi

	themes_dir=
	if [ -d "$root_dir/etc/bootsplash/themes" ]; then
	    themes_dir="$root_dir/etc/bootsplash/themes"
	elif [ -d "$root_dir/usr/share/splash/themes" ]; then
	    themes_dir="$root_dir/usr/share/splash/themes"
	fi

	no_splash=
	[ "$SPLASH" = "no" ] && no_splash=1
	case ${kernel_version##*-} in
	    kdump|um|xen*)
		no_splash=1
		;;
	esac

	if [ -n "$no_splash" ]; then
	    echo "No bootsplash for kernel flavor ${kernel_version##*-}"
	else
	    echo -ne "Bootsplash:\t"
	    if [ -n "$themes_dir" ] && \
		 [ -d "$themes_dir/$THEME" -o -L "$themes_dir/$THEME" ]; then
		for size in $splashsizes; do
		    bootsplash_picture="$themes_dir/$THEME/images/bootsplash-$size.jpg"
		    cfgname="$themes_dir/$THEME/config/bootsplash-$size.cfg"
		    if [ ! -r $cfgname ] ; then
			echo "disabled for resolution $size"
		    elif [ ! -r $bootsplash_picture ] ; then
			echo "no image for resolution $size"
		    else
			echo -n "${splash_image:+, }$THEME ($size)"
			splash_image="$splash_image $cfgname"
		    fi
		done
		echo
	    else
		echo "no theme selected"
	    fi
	fi
    fi

    # Include bootsplash image
    for image in $splash_image; do
	$splash_bin -s -f $image >> $tmp_mnt/bootsplash
    done

    attach_dsdt

    pushd . > /dev/null 2>&1
    cd $tmp_mnt
    find bin sbin -type f -print0 | xargs -0 chmod 0755 
    find . ! -name "*~" | cpio -H newc --create | gzip -9 > $tmp_initrd.gz
    popd > /dev/null 2>&1
    if ! cp -f $tmp_initrd.gz $initrd_image ; then
	oops 8 "Failed to install initrd"
    fi
    rm -rf $tmp_mnt

}

###################################################################

# working directories
tmp_initrd=$work_dir/initrd
tmp_initrd_small=${tmp_initrd}_small

if [ -z "$rootdev" ] ; then
  # no rootdev specified, get current root from /etc/fstab
  while read fstab_device fstab_mountpoint fstab_type fstab_options dummy ; do
    if [ "$fstab_mountpoint" = "/" ]; then
      rootdev="$fstab_device"
      rootfstype="$fstab_type"
      rootfsopts="$fstab_options"
      break
    fi
  done < <( sed -e '/^[ 	]*#/d' < $root_dir/etc/fstab)
else
  # get type from /etc/fstab or /proc/mounts (actually not needed)
  x1=$(sed -e'/^[ 	]*#/d' $root_dir/etc/fstab /proc/mounts 2>/dev/null \
       | grep -E "$rootdev[[:space:]]" | tail -n 1)
  rootfstype=$(echo $x1 | cut -f 3 -d " ")
fi

if [ -z "$rootdev" ] ; then
    if [ -z "$use_dhcp" ]; then
	error 1 "No '/' mountpoint specified in $root_dir/etc/fstab"
    else
	rootdev=
	rootfstype=nfs
    fi
fi

realrootdev="$rootdev"
case "$rootdev" in
    /dev/sd*)
	# Check for iSCSI
	sid=$(check_iscsi_root $rootdev)
	iscsi_root="$sid"
	;;
    LABEL=*|UUID=*)
	# get real root via fsck hack
	realrootdev=$(fsck -N "$rootdev" \
		      | sed -ne '2s/.* \/dev/\/dev/p' \
		      | sed -e 's/  *//g')
	if [ -z "$realrootdev" ] ; then
	    error 1 "Could not expand $rootdev to real device"
	fi
	realrootdev=$(/usr/bin/readlink -m $realrootdev)
	;;
    /dev/disk/*)
	realrootdev=$(/usr/bin/readlink -m $rootdev)
	# Check for iSCSI
	sid=$(check_iscsi_root $realrootdev)
	iscsi_root="$sid"
	;;
    *:*)
	rootdev=
	rootfstype=nfs
	;;
esac

# check for journal device
if [ "$rootfsopts" -a -z "$journaldev" ] ; then
    jdev=${rootfsopts#*,jdev=}
    if [ "$jdev" != "$rootfsopts" ] ; then
	journaldev=${jdev%%,*}
    fi
    logdev=${rootfsopts#*,logdev=}
    if [ "$logdev" != "$rootfsopts" ] ; then
	journaldev=${logdev%%,*}
    fi
fi

# check if the root device is an lvm device
root_lvm=
root_dm=
root_lvm2=
root_evms=
root_mpath=
root_md=
if [ -n "$realrootdev" -a -b "$root_dir/${realrootdev#/}" ] ; then
    rootdevn=$(devnumber $root_dir/${realrootdev#/})

    [ "$(block_driver "$root_dir/${realrootdev#/}")" = lvm ] \
	&& root_lvm=1
    [ "$(block_driver "$root_dir/${realrootdev#/}")" = device-mapper ] \
    	&& root_dm=1
    [ "$(block_driver "$root_dir/${realrootdev#/}")" = md ] \
    	&& root_md=1
    if [ "$root_dm" ] ; then
	major=$(devmajor $rootdevn)
	minor=$(devminor $rootdevn)
	# Check whether we are using EVMS
	if [ -x /sbin/evms ] ; then
	    region=$(echo "q:r" | evms -s -b | grep -B 2 "Minor: $minor\$" | grep -B 1 "Major: $major" | sed -n 's@Region Name: \(.\)@\1@p')
	    if [ "$region" ] ; then
		volume=$(echo "q:v,r=$region" | evms -s -b | sed -n 's@Volume Name: \(.*\)@\1@p')
		if [ -e "$volume" ] ; then
		    root_evms=1
		    realrootdev=$volume
		    line=$(sed -ne '/^[ \t]*#/d;/boot/p' /etc/fstab)
		    case "$line" in
			*/evms/*)
			    evms_policy=disk ;;
			*)
			    evms_policy=part ;;
		    esac
		fi
	    fi
	else
	    root_evms=
	fi
        # Check whether we are using LVM2
	if [ -z "$root_evms" ] && [ -x /sbin/lvdisplay ] ; then
	    vg_name=$(lvdisplay -c 2> /dev/null | sed -n "/.*:$major:$minor\$/p")
	    vg_dev=${vg_name%%:*}
	    vg_name=${vg_name#*:}
	    vg_root=${vg_name%%:*}
	    if [ "$vg_root" ] ; then
		root_lvm2=$(dmsetup info -o name --noheadings -c -j $major -m $minor)
		realrootdev=${vg_dev##  }
	    fi
	else
	    root_lvm2=
	fi
	if [ "$root_lvm2" ] ; then
	    # Check for LVM2 on top of md
	    md_list=
	    pv_list=$(vgs --noheadings --options devices $vg_root 2> /dev/null | sed "s@,@\n@g" | sed -n "s@([0-9]*)@@p;s@ @@g" | sort | uniq)
	    for dev in $pv_list ; do
		mdconf=$(mdadm -Db $dev 2> /dev/null)
		if [ -n "$mdconf" ] ; then
		    md_dev=${dev##/dev/}
		    md_list="$md_dev $md_list"
		    eval md_conf_${md_dev}=\"$mdconf\"
		fi
	    done
	    unset md_dev
	    unset mdconf
	    # Check for iscsi
	    for dev in $pv_list ; do
		case "$dev" in
		    /dev/sd*)
			sid=$(check_iscsi_root $dev)
			;;
		    /dev/dm-*)
			root_mpath=1
			;;
		esac
	    done
	    [ -n "$sid" ] && iscsi_root="$sid"
	    unset sid
	fi
    fi
    if [ "$root_md" ] && [ -x /sbin/mdadm ] ; then
	minor=$(devminor $rootdevn)
	# get md configuration
	mdconf=$(mdadm -Db $rootdev 2> /dev/null | sed -n "s@/dev/md[0-9]*@/dev/md$minor@p")
	if [ -n "$mdconf" ] ; then
	    md_dev=${rootdev##/dev/}
	    md_list="$md_dev"
	    eval md_conf_${md_dev}=\"$mdconf\"
	fi
	unset minor
	unset md_dev
	unset mdconf
    else
	root_md=
    fi
fi

###################################################################

x="$rootdev"
[ "$rootfstype" = "nfs" ] && x="nfs-root"
[ "$iscsi_root" ] && x="$(cat /sys/class/iscsi_session/$iscsi_root/targetname)"
[ "$rootdev" != "$realrootdev" ] && x="$x ($realrootdev)"
echo -e "Root device:\t$x (mounted on ${root_dir:-/} as $rootfstype)"

if [ -z "$modules_set" ]; then
    # get INITRD_MODULES from system configuration
    . $root_dir/etc/sysconfig/kernel
    for module in $INITRD_MODULES ; do
	module=$(echo $module | sed 's/-/_/g')
	modules="$modules $module"
    done
fi

if [ -z "$domu_modules_set" ]; then
    # get DOMU_INITRD_MODULES from system configuration
    . $root_dir/etc/sysconfig/kernel
    domu_modules="$DOMU_INITRD_MODULES"
fi

###################################################################
# add modules required by features
if [ "$rootfstype" = "nfs" ] ; then
    add_module nfs
fi

if [ -n "$root_lvm" ] ; then
    add_module lvm-mod
fi

if [ -n "$root_dm" ] ; then
    add_module dm-mod
    add_module dm-snapshot
fi

if [ -n "$md_list" ] ; then
    # load all md modules
    add_module raid0
    add_module raid1
    add_module raid5
    add_module linear
    if [ -f $root_dir/etc/mdadm.conf ] ; then
	# make sure we're overriding the default here
	md_list=
	root_md=1
    fi
fi

if [ -n "$root_dm" ] ; then
    # Add all required dm modules
    if [ -n "root_lvm2" ] ; then
	table=$(dmsetup table $root_lvm2 | cut -f 3 -d ' ')
	if [ "$table" != "linear" ] && [ "$table" != "striped" ] ; then
	    add_module dm-$table
	fi
    else
	dm_modules=$(dmsetup table | cut -f 4 -d ' ' | sort | uniq)
	for table in $dm_modules; do
	    if [ "$table" ] && [ "$table" != "linear" ] && [ "$table" != "striped" ] ; then
		add_module dm-$table
	    fi
	    # Always assume multipathing here if multipath table is loaded
	    if [ "$table" == "multipath" ] ; then
		root_mpath=1
	    fi
	done
    fi
    if [ "$root_mpath" ] ; then
	add_module dm-round-robin
	add_module dm-emc
	add_module dm-rdac
	add_module dm-hp_sw
	add_module dm-alua
    fi
fi

if [ -n "$iscsi_root" ] ; then
    add_module scsi_transport_iscsi
    add_module iscsi_tcp
    if [ -z "$interface" ] ; then
	ifspec=$(get_default_interface)
	interface=${ifspec%%/*}
	bootproto=${ifspec##*/}
	if [ "$bootproto" = "dhcp" ] ; then
	    use_dhcp=1
	else
	    use_ipconfig=1
	fi
    fi
fi

if [ -n "$interface" ] ; then
    # Pull in network module
    if [ -d /sys/class/net/$interface/device ] ; then
	if [ -f /sys/class/net/$interface/device/modalias ] ; then
	    read drvlink  < /sys/class/net/$interface/device/modalias
	elif [ -f /sys/class/net/$interface/device/driver/module ] ; then
	    drvlink=$(cd /sys/class/net/$interface/device/driver; readlink module)
	else
	    drvlink=$(cd /sys/class/net/$interface/device; readlink driver)
	fi
	# xen network driver registers as 'vif'
	ifmod=${drvlink##*/}
	if [ "$ifmod" == "vif" ] ; then
	    ifmod=xennet
	    for mod in $domu_modules; do
		if [ "$mod" == "xennet" ] ; then
		    ifmod=
		    break;
		fi
	    done
	fi
	if [ "$ifmod " ] ; then
	    add_module $ifmod
	fi
	read macaddress < /sys/class/net/$interface/address
    fi
fi

if [ -n "$use_dhcp" ]; then
    # dhcpd reqires the af_packet module, we include it here
    # in case the root FS will be mounted via NFS
    add_module af_packet
fi

case "$(uname -m)" in
    s390|s390x)
	# Check if zfcp or dasd modules need to be added automatically:
	if [ -d /sys/block ]; then
	    # Always enable all devices, hotplug is completely garbled
	    s390_enable_dasd=1
	    s390_enable_zfcp=1
	    # if [ "$root_evms" ]; then
	    #     s390_check_evms $rootdev
	    # elif [ "$root_dm" ]; then
	    #     s390_check_lvm2 $rootdev
	    # else
	    #     s390_check_dasd $rootdev
	    #     s390_check_zfcp $rootdev
	    # fi
	    # Activate devices
	    s390_dasd_sysfs
	    s390_zfcp_sysfs
	else
	    echo ""
	    echo "WARNING: sysfs not mounted on /sys."
	    echo "Booting from zfcp will _not_ work."
	    s390_dasd_proc
	fi
    ;;
esac

###################################################################

exit_code=0

initrd_images=( $initrd_images )
kernel_images=( $kernel_images )

boot_modules="$modules"
echo -e "Module list:\t$boot_modules ($domu_modules)"
for ((i=0 ; $i<${#kernel_images[@]} ; i++)); do
    echo
    modules="$boot_modules"
    kernel_image=${kernel_images[$i]}
    [ ${kernel_image:0:1} != '/' ] \
    	&& kernel_image=$boot_dir/$kernel_image

    initrd_image=${initrd_images[$i]}
    [ ${initrd_image:0:1} != '/' ] \
    	&& initrd_image=$boot_dir/$initrd_image

    mkinitrd_kernel $kernel_image $initrd_image

    # If the current $kernel_image has a symlink without "-<version>" (e.g.
    # "vmlinuz") pointing to it, create an "initrd" symlink for the
    # corresponding $initrd_image.
    if [ $exit_code -eq 0 -a "$(readlink ${kernel_image%%-*})" = \
	 "${kernel_image#$boot_dir/}" ]; then
	rm -f $root_dir/$boot_dir/initrd
	ln -s "${initrd_image#$boot_dir/}" $root_dir/$boot_dir/initrd
    fi
    cleanup
done

cleanup_finish

if [ -e $root_dir/etc/sysconfig/bootloader ]; then
    . $root_dir/etc/sysconfig/bootloader
fi
case $LOADER_TYPE in
  lilo)
    echo "
Run lilo now to update the boot loader configuration."
    ;;
  elilo)
    if [ -x /sbin/elilo ]; then
      /sbin/elilo
    else
      echo "
You may now have to update the elilo boot loader configuration."
    fi
    ;;
  grub)
    ;;
  *)
    if [ -f "$root_dir/etc/zipl.conf" ]; then
	echo "
initrd updated, zipl needs to update the IPL record before IPL!"
    else
	echo "
You may now have to update your boot loader configuration."
    fi
    ;;
esac

exit $exit_code
