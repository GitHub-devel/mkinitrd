#! /bin/bash

# mkinitrd - create the inital ramdisk images
# usage: see below usage() or call with -h
#
# Copyright (C) 1999-2004 SuSE Linux AG, Nuernberg, Germany
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
# USA.

# This file is kept in the following CVS repository:
#
# $Source: /suse/yast2/cvsroot/mkinitrd/bonked/Attic/mkinitrd,v $
# $Revision: 1.73 $

#
# Print usage and exit
#
usage() {
    cat<<EOM
	Create initial ramdisk images that contain all kernel modules
	needed in the early boot process, before the root file system
	becomes available. This usually includes SCSI and/or RAID
	modules, a file system module for the root file system, or
	a network interface driver module for dhcp.

        mkinitrd [options] [root_dir]

        options:
          -h               This Text.
          -k "kernel list" List of kernel images for which initrd files
                           are created. Defaults to all kernels found
			   in /boot.
          -i "initrd list" List of file names for the initrd; position
	  		   have match to "kernel list". Defaults to all
			   all kernels found in /boot.
          -m "module list" Modules to include in initrd. Defaults to the
                           INITRD_MODULES variable in /etc/sysconfig/kernel.
          -b boot_dir      Boot directory. Defaults to /boot.
          -d root_device   Root device. Defaults to the device from which
                           the root_dir is mounted. Overrides the rootdev
                           enviroment variable if set.
	  -s size          Add splash animation and bootscreen to initrd.
	  -t tmp_dir       Temporary directory. Defaults to $root_dir/var/tmp.
	  -D interface     Run dhcp on the specified interface.
	  -a acpi_dsdt     Attach compiled ACPI DSDT (Differentiated System
	  		   Description Table) to initrd. This replaces the
			   DSDT of the BIOS. Defaults to the ACPI_DSDT
			   variable in /etc/sysconfig/kernel.
	  -S               Load policy file for SELinux if exist.
	  -u               Disable the use of udev
        root_dir:          The directory the root partition is mounted on.
                           Defaults to "/".
EOM
    exit
}

# Readlink is not present on some older distributions: emulate it.
readlink() {
    local path=$1 ll

    if [ -L "$path" ]; then
	ll="$(LC_ALL=C ls -l "$path" 2> /dev/null)"
	echo "${ll/* -> }"
    else
	return 1
    fi
}

default_kernel_images () {
	local regex kernel_image kernel_version version_version initrd_image
	local qf='%{NAME}-%{VERSION}-%{RELEASE}\n'

	case "$arch" in
		s390*)	regex='image'
			;;
		ppc)	regex='vmlinu[xz]\(64\)\?'
			;;
		*)	regex='vmlinuz'
			;;
	esac

	kernel_images=""
	initrd_images=""
	for kernel_image in $(ls $root_dir/boot \
		| sed -ne "\|^$regex\(-[0-9.]\+-[0-9]\+-[a-z0-9]\+$\)\?|p") ; do

		# Note that we cannot check the RPM database here -- this
		# script is itself called from within the binary kernel
		# packages, and rpm does not allow recursive calls.

		[ -L "$root_dir/boot/$kernel_image" ] && continue
		kernel_version=$(/sbin/get_kernel_version \
				 $root_dir/boot/$kernel_image 2> /dev/null)
		initrd_image=$(echo $kernel_image | sed -e "s|${regex}|initrd|")
		if [ "$kernel_image" != "$initrd_image" -a \
		     -n "$kernel_version" -a \
		     -d "$root_dir/lib/modules/$kernel_version" ]; then
			kernel_images="$kernel_images /boot/$kernel_image"
			initrd_images="$initrd_images /boot/$initrd_image"
		fi
	done
}

# You can specify the root device via the environment variable rootdev (e.g.
# "rootdev=/dev/hda mkinitrd").

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# general configurable parameters

kernel_images=
initrd_images=
modules=
modules_set=
boot_dir=
splash="auto"
use_pivot_root=
use_static_binaries=1
acpi_dsdt=
use_selinux=
use_udev=1

# architecture dependend changes:
arch=$(uname -m)
arch=${arch/ppc64/ppc}
arch=${arch/s390x/s390}

case $arch in
s390)
    splash=off
    ;;
esac

while getopts :hk:i:m:b:d:o:s:St:D:a:u a ; do
    case $a in
	\:|\?)	case $OPTARG in
		k)  echo "-k requires kernel list parameter"
		    ;;
		i)  echo "-i requires initrd list parameter"
		    ;;
		m)  echo "-m requires module list parameter"
		    ;;
		b)  echo "-b requires boot dir parameter"
		    ;;
		d)  echo "-d requires root device parameter"
		    ;;
		s)  echo "-s requires image size(s)"
		    ;;
		t)  echo "-t requires tmp dir parameter"
		    ;;
		D)  echo "-D requires dhcp interface parameter"
		    ;;
		a)  echo "-a requires a DSDT parameter"
		    ;;
		*)  echo "Unknown option: -$OPTARG"
		    echo "Try mkinitrd -h"
		    ;;
	    esac
	    exit 1
	    ;;
	k)  kernel_images=$OPTARG
	    ;;
	i)  initrd_images=$OPTARG
	    ;;
	m)  modules=$OPTARG
	    modules_set=1
	    ;;
	b)  boot_dir=$OPTARG
	    ;;
	d)  rootdev=$OPTARG
	    ;;
	s)  splash=$OPTARG
	    ;;
	t)  tmp_dir=$OPTARG
	    ;;
	D)  dhcp_interface=$OPTARG
	    dhcp_interface=${dhcp_interface#/dev/}
	    use_pivot_root=1
	    ;;
	a)  acpi_dsdt="$OPTARG"
	    ;;
	S)  use_selinux=1
	    ;;
	u)  use_udev=
	    ;;
	h)  usage
	    ;;
    esac
done
shift $(expr $OPTIND - 1)

if [ -n "$1" ]; then
    root_dir=${1%/}  # strip trailing slash
else
    root_dir=
fi

if [ -n "$boot_dir" ]; then
    boot_dir="${boot_dir#/}"
    boot_dir="/${boot_dir%/}"
else
    boot_dir="/boot"
fi
if [ ! -d "$boot_dir" ]; then
    echo "$boot_dir is not a directory" >&2
    exit 1
fi

# FIXME agruen: tmp_dir is the full, absolute path to a temporary directory
# that must not be a tmpfs file system. This was not consistently used in
# the previous version of mkinitrd.

if [ -n "$tmp_dir" ]; then
    tmp_dir="/${tmp_dir#/}"  # make sure it is an absolute path
else
    tmp_dir=$root_dir/var/tmp
fi
if [ ! -d "$tmp_dir" ]; then
    echo "$tmp_dir is not a directory" >&2
    exit 1
fi

# FIXME agruen: tmp_dir defaults to $root_dir/var/tmp. Not very nice
# to write into a directory of another installation without explicitly
# being asked to.
#
# If tmp_dir is unspecified, find a non-tmpfs temporary directory:
# /var/tmp, $root_dir/var/tmp, /tmp, $root_dir/tmp, etc.

# Check if the -k and -i settings are valid.
if [ $(set -- $kernel_images ; echo $#) -ne \
     $(set -- $initrd_images ; echo $#) ]; then
    echo "You have to specify -k and -i, or none of both. The -k" \
         "and -i options must each contain the same number of items." >&2
    exit 1
fi

if [ -z "$kernel_images" -o -z "$initrd_images" ]; then
    default_kernel_images
fi


# Check which shell and insmod binaries to use in initrd.
[ -x $root_dir/bin/ash ] \
    && initrd_shell_dynamic=$root_dir/bin/ash
if [ -n "$use_static_binaries" ]; then
    if [ -x $root_dir/bin/ash.static ]; then
	initrd_shell=$root_dir/bin/ash.static
    else
	initrd_shell=/bin/ash.static
    fi
else
    initrd_shell=$initrd_shell_dynamic
fi

# The shell-bang line to use inside initrd.
shebang=${initrd_shell#$root_dir}
shebang=${shebang%.static}
if [ -n "$use_udev" ]; then
    if [ -x /lib/klibc/bin/sh ]; then
	shebang="/bin/ash"
	initrd_shell="/lib/klibc/bin/sh"
	initrd_shell_dynamic=
    fi
fi

[ -x $root_dir/sbin/insmod ] \
    && initrd_insmod_dynamic=$root_dir/sbin/insmod
if [ -n "$use_static_binaries" ]; then
    if [ -x $root_dir/sbin/insmod.static ]; then
	initrd_insmod=$root_dir/sbin/insmod.static
    else
	initrd_insmod=/sbin/insmod.static
    fi
else
    initrd_insmod=$initrd_insmod_dynamic
fi

# FIXME agruen: Is is really necessary to fall back to /bin/ash.static
# and /sbin/initrd.static outside the $root_dir?

# maximum initrd size
image_blocks=20480
image_inodes=2048

# handle splash screen
case "$splash" in
off)
    splashsizes= ;;
auto)
    splashsizes=
    bootconf=/dev/null
    [ -f $root_dir/etc/lilo.conf ] \
	&& bootconf="$bootconf $root_dir/etc/lilo.conf"
    [ -f $root_dir/boot/grub/menu.lst ] \
	&& bootconf="$bootconf $root_dir/boot/grub/menu.lst"
    for vga in $(sed -e '/^[ \t]*#/d' -e 's/ \+/\n/g' $bootconf \
	    	 | sed -ne 's/^vga[ \t]*=[ \t]*\(.*\)/\1/p' \
		 | sed -ne '/^\([0-9]\+\|0[xX][0-9a-fA-F]\+\)$/p'); do
	splashsize=
	case $(($vga)) in  # $((...)) : Convert 0xFOO to decimal
	    785|786) splashsize=640x480   ;;
	    788|789) splashsize=800x600   ;;
	    791|792) splashsize=1024x768  ;;
	    794)     splashsize=1280x1024 ;;
	    795)     splashsize=1280x1024 ;;
	    *)	     vgahex=$(printf 0x%04x "$(($vga))")
		     splashsize=$(hwinfo debug=0 -all +bios.vbe | sed -ne \
				   's/^.*Mode '$vgahex': \([^ ]\+\) .*$/\1/p' \
				  2>/dev/null) ;;
	esac
	[ -n "$splashsize" -a "${splashsizes/$splashsize/}" = "$splashsizes" ] \
	    && splashsizes="$splashsizes $splashsize"
    done ;;
*)
    splashsizes=$splash ;;
esac

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# should be nothing to change below...

PATH=/sbin:/usr/sbin:$PATH

work_dir=$(mktemp -qd $tmp_dir/mkinitrd.XXXXXX)
if [ $? -ne 0 ]; then
	echo "$0: Can't create temp dir, exiting." >&2
	exit 1
fi
is_mounted=
is_mounted_small=

umount_proc() {
    [ "$mounted_proc" ] && umount $mounted_proc
    mounted_proc=
}

cleanup () {
    [ "$is_mounted" ] && umount $tmp_mnt
    is_mounted=
    [ "$is_mounted_small" ] && umount $tmp_mnt_small
    is_mounted_small=
    rm -f $tmp_initrd $tmp_initrd.gz $tmp_msg tmp_initrd_small \
	  $tmp_initrd_small.gz
    [ -d "$tmp_mnt" ] && rmdir $tmp_mnt
    [ -d "$tmp_mnt_small" ] && rmdir $tmp_mnt_small
}

cleanup_finish () {
    umount_proc
    [ -d "$work_dir" ] && rmdir $work_dir
}

handle_terminate () {
    echo "(received signal)

Interrupted, cleaning up." >&2
    cleanup
    cleanup_finish
    exit 255
}

trap handle_terminate 1 2 3 15

error () {
    echo "$2" >&2
    cleanup
    cleanup_finish
    exit $1
}

oops () {
    exit_code=$1
    shift
    echo "$@" >&2
}

# Check if module $1 is listed in $modules.
has_module () {
    case " $modules " in
	*" $1 "*)   return 0 ;;
    esac
    return 1
}

# Check if any of the modules in $* are listed in $modules.
has_any_module () {
    local module
    for module in "$@"; do
	has_module "$module" && return 0
    done
}

# Add module $1 at the end of the module list.
add_module () {
    local module
    for module in "$@"; do
	has_module "$module" || modules="$modules $module"
    done
}

# Install a binary file
cp_bin () {
    cp -a "$@"

    # Remember the binaries installed. We need the list for checking
    # for dynamic libraries.
    while [ $# -gt 1 ]; do
	initrd_bins[${#initrd_bins[@]}]=$1
	shift
   done
}

do_chroot() {
    local CHROOT
    if [ -n "$root_dir" ]; then
	CHROOT=/usr/bin/chroot
	if [ ! -x $CHROOT ]; then
	    error 2 "I need $CHROOT."
	else
	    $CHROOT "$@"
	fi
    else
	"$@"
    fi

}

# Resolve dynamic library dependencies. Returns a list of symbolic links
# to shared objects and shared object files for the binaries in $*. The
# binaries must be relative to $root_dir.
shared_object_files () {
    local LDD CHROOT initrd_libs lib_files lib_links lib link

    LDD=/usr/bin/ldd
    if [ ! -x $root_dir$LDD ]; then
	error 2 "I need $root_dir$LDD."
    fi

    initrd_libs=( $(
	do_chroot $LDD "${@#$root_dir}" \
	| sed -e '\: => :!d' -e 's:.* => \([^ ]*\).*:\1:'
    ) )

    # Evil hack: On some systems we have generic as well as optimized
    # libraries, but the optimized libraries may not work with all
    # kernel versions (e.g., the NPTL glibc libraries don't work with
    # a 2.4 kernel). Use the generic versions of the libraries in the
    # initrd (and guess the name).
    local n optimized
    for ((n=0; $n<${#initrd_libs[@]}; n++)); do
	lib=${initrd_libs[$n]}
	optimized="$(echo "$lib" | sed -e 's:.*/\([^/]\+/\)[^/]\+$:\1:')"
	lib=${lib/$optimized/}
	if [ "${optimized:0:3}" != "lib" -a -f "$lib" ]; then
	    #echo "[Using $lib instead of ${initrd_libs[$n]}]" >&2
	    initrd_libs[$n]="${lib/$optimized/}"
	fi
    done

    for lib in "${initrd_libs[@]}"; do
	case "$lib" in
	linux-gate*)
	    # This library is mapped into the process by the kernel
	    # for vsyscalls (i.e., syscalls that don't need a user/
	    # kernel address space transition) in 2.6 kernels.
	    continue ;;
	/*)
	    lib="${lib:1}" ;;
	*)
	    # Library could not be found.
	    oops 7 "Dynamic library $lib not found"
	    continue ;;
	esac

	while [ -L "$root_dir/$lib" ]; do
	    echo $lib
	    link="$(readlink "$root_dir/$lib")"
	    if [ x"${link:0:1}" == x"/" ]; then
	        lib=${link#/}
	    else
	        lib="${lib%/*}/$link"
	    fi
	done
	echo $lib
    done \
    | sort -u
}

# Resolve module dependencies and parameters. Returns a list of modules and
# their parameters. The module names returned are relative to $root_dir.
resolve_modules () {
    local kernel_version=$1 module
    shift

    for module in "$@"; do
	module=${module#.o}  # strip trailing ".o" just in case.
	module=${module#.ko}  # strip trailing ".ko" just in case.
	case $kernel_version in
	2.4.*)
	    # Really old systems don't have modprobe.old.
	    local modprobe
	    if [ -e $root_dir/sbin/modprobe.old ]; then
	       modprobe=$root_dir/sbin/modprobe.old
	    else
	       modprobe=$root_dir/sbin/modprobe
	    fi
	    tmp_conf="$(mktemp $root_dir/tmp/mkinitrd.XXXXXX)"
	    {   echo "depfile=/lib/modules/$kernel_version/modules.dep"
		[ -f $root_dir/etc/modules.conf ] \
		    && sed -e '/^[ \t]*depfile=/d' $root_dir/etc/modules.conf
	    } > "$tmp_conf"
	    module_list=$( do_chroot \
	    	${modprobe#$root_dir} -C "${tmp_conf#$root_dir}" \
				      -v -n $module 2> /dev/null \
		| sed -ne 's:.*insmod /\?::p' )
	    rm -f "$tmp_conf"
	    ;;
	*)
	    local with_modprobe_conf
	    if [ -e $root_dir/etc/modprobe.conf ]; then
		with_modprobe_conf="-C /etc/modprobe.conf"
	    fi
	    module_list=$( do_chroot \
	       /sbin/modprobe $with_modprobe_conf \
			      --set-version $kernel_version \
			      --show-depends $module 2> /dev/null \
	       | sed -ne 's:.*insmod /\?::p' )
	    ;;
	esac
	if [ -z "$module_list" ]; then
	    case $module in
	    scsi_mod|sd_mod|md)  # modularized in 2.4.21
		# These modules were previously compiled into the kernel,
		# and were modularized later. They will be missing in older
		# kernels; ignore error messages.
	    	;;
	    xfs_dmapi|xfs_support)  # gone in 2.4.20
		# These modules do no longer exist. Do not produce an error
		# message, but warn that they should be removed manually.
    		echo -n "Warning: Module $module no longer exists, and" \
		     "should be removed " >&2
	        if [ -e $root_dir/etc/sysconfig/kernel ]; then
		    echo "from /etc/sysconfig/kernel." >&2
	        elif [ -e $root_dir/etc/rc.config ]; then
		    echo "from /etc/rc.config." >&2
		else
		    echo "." >&2
		fi
		;;
	    *)
		oops 7 "Cannot determine dependencies of module $module." \
		       "Is modules.dep up to date?"
		;;
	    esac
	fi
	echo "$module_list"
    done \
    | awk ' # filter duplicates: we must not reorder modules here!
	$1 in seen  { next }
		    { seen[$1]=1
		      print
		    }
    '
    rm -f $temp
}

# Test if file $1 is smaller than file $2 (kilobyte granularity)
smaller_file () {
    local size1=$(ls -l "$1" |awk '{print $5}')
    local size2=$(ls -l "$2" |awk '{print $5}')
    [ $size1 -lt $size2 ]
}

# Cat from stdin to linuxrc, removing leading whitespace up to pipe symbol.
# Note that here documents can only be indented with tabs, not with spaces.
cat_linuxrc () {
    sed 's/^[ \t]*|//' >> $linuxrc
    echo >> $linuxrc
}

# Attach ACPI DSDT if necessary.
attach_dsdt () {
    local initrd_image=$1

    if [ -z "$acpi_dsdt" ]; then
	if [ -f "$root_dir/etc/sysconfig/kernel" ]; then
	    . $root_dir/etc/sysconfig/kernel
	    acpi_dsdt="$ACPI_DSDT"
	fi
    fi
    if [ -z "$acpi_dsdt" ]; then
	return
    fi
    if [ ! -f "$acpi_dsdt" ]; then
	oops 2 "ACPI DSDT $acpi_dsdt does not exist."
	return
    fi
    if ! grep -q "DSDT" "$acpi_dsdt" ; then
	oops 2 "File $acpi_dsdt is not a valid ACPI DSDT. Ignoring."
    elif grep -qE 'DefinitionBlock|char|dsl|aml' "$acpi_dsdt" ; then
    	oops 2 "ACPI DSDT $acpi_dsdt does not seem to be in binary form." \
	       "Will not attach this to $initrd_image."
    else
	{   echo -ne "INITRDDSDT123DSDT123\0"
	    cat "$acpi_dsdt"
	    echo -ne "INITRDDSDT321DSDT321\0"
	} >> $initrd_image
	echo -e "ACPI DSDT:\t$acpi_dsdt"
    fi
}

# Check for IDE module
check_ide_modules () {
    local modules_dir=$1 ide_modules

    # Check for PCI bus
    if [ ! -d /proc/bus/pci ]; then
        # Not found, no error
        return
    fi

    pcimap_file="${modules_dir}/modules.pcimap"

    if [ ! -f "$pcimap_file" ] ; then
	echo "No modules.pcimap file found" >&2
	return
    fi

    echo -e -n "IDE modules:\t"

    while read pci_id none class_id dev_id rev_id; do
	saved_IFS="$IFS"
	IFS=":"
	set -- $dev_id
	vendor_id=$1
	device_id=$2
	IFS="$saved_IFS"
	if [ "$class_id" == "0101:" ] ; then
	    pci_vendor_id=$(printf "0x%08x" $((0x$vendor_id)))
	    pci_device_id=$(printf "0x%08x" $((0x$device_id)))
	    line=$(grep "$pci_vendor_id $pci_device_id" $pcimap_file)
	    if [ "$line" ]; then
		set -- $line
		add_module $1
		ide_modules="$ide_modules $1"
		echo -n "$1 "
	    fi
	fi
    done < <(/sbin/lspci -n)
    if [ "$ide_modules" ]; then
	add_module ide-disk
	add_module ide-floppy
	add_module ide-cd
	echo
    else
	echo "none"
    fi
}

# Create the initrd image $2 for kernel $1 (both are absolute path names).
mkinitrd_kernel () {
    local kernel_image=$1 initrd_image=$2
    local kernel_version need_mount sysfs_root

    tmp_mnt=$work_dir/mnt
    tmp_mnt_small=${tmp_mnt}_small
    tmp_msg=$work_dir/msg$$
    linuxrc=$tmp_mnt/linuxrc

    if ! [ -f "$root_dir$kernel_image" ] ; then
	echo "No kernel image $root_dir$kernel_image found" >&2
	return
    fi

    kernel_version=$(/sbin/get_kernel_version $root_dir$kernel_image)

    echo -e "Kernel version:\t$kernel_version ($HOSTTYPE)"
    echo -e "Kernel image:\t$root_dir$kernel_image"
    echo -e "Initrd image:\t$root_dir$initrd_image"

    if [ ! -d "$root_dir/lib/modules/$kernel_version/misc" -a \
	 ! -d "$root_dir/lib/modules/$kernel_version/kernel" ]; then
	oops 2 "No modules found for kernel $kernel_version"
        return
    fi

    # create an empty initrd
    mkdir $tmp_mnt || error 1 "could not create temporary directory"
    dd if=/dev/zero of=$tmp_initrd bs=1k count=$image_blocks 2>/dev/null
    mke2fs -q -F -b 1024 -m 0 -N $image_inodes $tmp_initrd 2>/dev/null 1>&2
    tune2fs -i 0 $tmp_initrd >/dev/null 2>&1

    # check for loop device
    grep -q loop /proc/devices
    if [ $? != 0 ] ; then
	if [ -f /lib/loop.o ] ; then
	    insmod /lib/loop.o
	else
	    modprobe loop
	fi
    fi
    # mount it
    if ! mount -t ext2 -oloop $tmp_initrd $tmp_mnt ; then
	error 3 "failed to mount image"
    fi
    is_mounted=1
    # fill the initrd
    rmdir $tmp_mnt/lost+found
    mkdir -p $tmp_mnt/{sbin,bin,dev}
    initrd_devices=$(echo dev/{zero,null,ram0,ram1,ram2,ram,ramdisk} \
			  dev/{console,md0})
    case $arch in
	s390*)
	    ;;
	*)  initrd_devices="$initrd_devices $(echo dev/{fb0,tty1,tty2})"
	    ;;
    esac
    (cd ${root_dir:-/} ; cp -R --parents $initrd_devices $tmp_mnt )
    cp_bin $initrd_shell $tmp_mnt$shebang 2>/dev/null \
	|| error 4 "no static shell"
    cp_bin $initrd_insmod $tmp_mnt/sbin/insmod 2>/dev/null \
	|| error 5 "no static insmod"

    # If exists, copy also insmod.static.old, it is created by modutils for
    # 2.5.47+ kernels and it is needed by these to work with older kernels.
    if [ -r $initrd_insmod.old ] ; then
      cp_bin $initrd_insmod.old $tmp_mnt/sbin/insmod.old 2>/dev/null
    fi

   # SELinux: Binary policy file and load_policy utility for loading it.
   if [ -n "$use_selinux" ] ; then
	if [ -f $root_dir/etc/security/selinux/policy.15 -a \
	     -f $root_dir/usr/sbin/load_policy ] ; then
	   echo -e "SELinux policy:\tadded"
	   mkdir -p $tmp_mnt/selinux
	   mkdir -p $tmp_mnt/etc/security/selinux
	   cp -p $root_dir/etc/security/selinux/policy.15 \
	       $tmp_mnt/etc/security/selinux
	   cp_bin $root_dir/usr/sbin/load_policy $tmp_mnt/sbin/load_policy
	else
	   echo -e "SELinux policy:\tnot found"
	fi
    fi

    case "$kernel_version" in
    2.6*)
	sysfs_root=1
	use_udev=1
	;;
    *)
	use_udev=
	;;
    esac

    if has_module iscsi ; then
	cp_bin $root_dir/usr/sbin/iscsid $tmp_mnt/sbin/iscsid
	cp_bin $root_dir/bin/usleep $tmp_mnt/bin/usleep
	need_mount=1
    fi

    if [ -n "$sysfs_root" ]; then
	mkdir -p $tmp_mnt/sys
	cp_bin $root_dir/usr/bin/expr $tmp_mnt/bin
	cp_bin $root_dir/bin/cat $tmp_mnt/bin
	need_mount=1
    fi

    if [ -n "$use_udev" ] ; then
	if [ -x $root_dir/lib/klibc/bin/sleep ]; then
	    cp_bin $root_dir/lib/klibc/bin/sleep $tmp_mnt/bin
	else
	    cp_bin $root_dir/bin/sleep $tmp_mnt/bin
	fi
	cp_bin $root_dir/sbin/udev $tmp_mnt/sbin/udev
	cp_bin $root_dir/sbin/udevinfo.static $tmp_mnt/sbin/udevinfo
	cp_bin $root_dir/sbin/udevstart $tmp_mnt/sbin/udevstart
	cp_bin $root_dir/sbin/scsi_id $tmp_mnt/sbin
	cp_bin $root_dir/sbin/udev.*.sh $tmp_mnt/sbin
	mkdir -p $tmp_mnt/etc/udev
	cp -a $root_dir/etc/udev/* $tmp_mnt/etc/udev
    fi

    if [ -n "$root_lvm" ] ; then
	echo "Including LVM support"
	mkdir -p $tmp_mnt/etc/lvmtab.d
	cp -a $root_dir/dev/lvm  $tmp_mnt/dev
	cp_bin $root_dir/sbin/{vgscan,vgchange} $tmp_mnt/sbin
	cp_bin $root_dir/bin/cat $tmp_mnt/bin
	need_mount=1
    fi

    if [ -n "$root_dm" ] ; then
	echo "Including DM/LVM2 support"
	mkdir -p $tmp_mnt/etc/lvm
	cp -a $root_dir/dev/mapper  $tmp_mnt/dev
	cp_bin $root_dir/sbin/{vgscan,vgchange,lvm,devmap_mknod.sh} $tmp_mnt/sbin
	cp_bin $root_dir/bin/{cat,sed,mkdir,mknod} $tmp_mnt/bin
	need_mount=1
    fi

    if [ -n "$use_pivot_root" ] ; then
	echo "Including pivot root support"
	cp_bin $root_dir/sbin/pivot_root $tmp_mnt/bin
	cp_bin $root_dir/bin/cat $tmp_mnt/bin
	echo "#! $shebang" > $tmp_mnt/bin/init
	echo 'echo initrd failed, goodbye...' >> $tmp_mnt/bin/init
	chmod 755 $tmp_mnt/bin/init
	mkdir -p $tmp_mnt/mnt
	need_mount=1
    fi

    if [ -n "$dhcp_interface" ] ; then
	echo " Using dhcp on $dhcp_interface"
	cp_bin $root_dir/sbin/dhcpcd $tmp_mnt/bin
	cp_bin $root_dir/bin/kill $tmp_mnt/bin
	mkdir -p $tmp_mnt/var/lib/dhcpcd
	mkdir -p $tmp_mnt/var/run
	need_mount=1
    fi

    if has_module jfs ; then
	echo "Including JFS recovery support"
	cp_bin $root_dir/sbin/fsck $tmp_mnt/bin
	cp_bin $root_dir/sbin/fsck.jfs $tmp_mnt/bin
	need_mount=1
    fi

    if has_module scsi_mod ; then
	cp_bin $root_dir/bin/cat $tmp_mnt/bin
	need_mount=1
    fi

    if [ -n "$need_mount" ] ; then
	mkdir -p $tmp_mnt/{etc,proc,mnt}
	echo 'none /proc proc defaults 0 0' > $tmp_mnt/etc/fstab
	if [ "$sysfs_root" ] ; then
	    echo 'sysfs /sys sysfs defaults 0 0' > $tmp_mnt/etc/fstab
	fi
	cp_bin $root_dir/bin/{mount,umount} $tmp_mnt/bin
	
	if [ -z "$use_udev" -a -z "$use_pivot_root" -a \
	     -b "$root_dir/$rootdev" ] ; then
	    mkdir -p $tmp_mnt/${rootdev%/*}
	    cp -a $root_dir/$rootdev $tmp_mnt/${rootdev%/*}
	fi
    fi

    # DEBUG: cp_bin /bin/ls $tmp_mnt/bin

    echo -ne "Shared libs:\t"
    # Only check those binaries against dynamic libraries that were
    # taken from the root_dir: We don't want to go into library
    # hell by adding libraries in different versions!
    bin_files=$(
	for bin in "${initrd_bins[@]}" ; do
	    case $bin in
	        ($root_dir*)
		    echo "${bin#$root_dir}"
		    ;;
	    esac
	done )

    # Copy all required shared libraries and the symlinks that
    # refer to them.
    lib_files=$(shared_object_files $bin_files)
    if [ -n "$lib_files" ]; then
	for lib in $lib_files; do
	    [ -L $root_dir/$lib ] || echo -n "$lib "
	    ( cd ${root_dir:-/} ; cp -dp --parents $lib $tmp_mnt )
	done
	echo
    else
	echo "none"
    fi

    if [ -n "$lib_files" -a -n "$initrd_shell_dynamic" ]; then
	# If we have already have all dynamic libraries that
	# $initrd_shell_dynamic is using, and if $initrd_shell_dynamic
	# is smaller than $initrd_shell, we can save a little space
	# by using the dynamic version. The benefit is marginal, though.

	if smaller_file $initrd_shell_dynamic $initrd_shell ; then
	    for lib in $(shared_object_files $initrd_shell_dynamic) ; do
		case $lib_files in
		    *$lib*) ;;
		    *)	initrd_shell_dynamic=
		    	break ;;
		esac
	    done
	    if [ -n "$initrd_shell_dynamic" ]; then
		#echo " - Using dynamically linked $shebang"
		cp_bin $initrd_shell_dynamic $tmp_mnt$shebang
	    fi
	fi
    fi

    if [ -n "$lib_files" -a -n "$initrd_insmod_dynamic" ]; then
	# If we have already have all dynamic libraries that
	# $initrd_insmod_dynamic is using, and if $initrd_insmod_dynamic
	# is smaller than $initrd_insmod, we can save a little space
	# by using the dynamic version. The benefit is marginal, though.

	if smaller_file $initrd_insmod_dynamic $initrd_insmod ; then
	    for lib in $(shared_object_files $initrd_insmod_dynamic); do
		case $lib_files in
		    *$lib*) ;;
		    *)	initrd_insmod_dynamic=
		    	break ;;
		esac
	    done
	    if [ -n "$initrd_insmod_dynamic" ]; then
		#echo " - Using dynamically linked /sbin/insmod"
		cp_bin $initrd_insmod_dynamic $tmp_mnt/sbin/insmod
	    fi
	fi
    fi

    cat /dev/null > $linuxrc
    chmod 755 $linuxrc

    # Note that the in-place documents must be indented with tabs, not spaces.

    cat_linuxrc <<-EOF
	|#! $shebang
	|
	|export PATH=/sbin:/bin:/usr/bin
	|
	|mount -n -tproc proc /proc
	|mount -n -tsysfs sysfs /sys > /dev/null 2>&1
	|
	|die() {
	|	umount -n /proc
	|	umount -n /sys
	|	exit \$1
	|}
	|
	|root_arg() {
	|   set -- \$(cat /proc/cmdline)
	|   while [ \$# -gt 1 ]; do
	|	case \$1 in
	|	root=*)
	|	    IFS==
	|	    set -- \$1
	|	    echo \$2
	|	    return 0 ;;
	|	esac
	|	shift
	|   done
	|   return 1
	|}
	EOF

    # Start udev if necessary
    if [ -n "$use_udev" ]; then
	cat_linuxrc <<-EOF
	|
	|root_dev_t=$root_dev_t
	|
	|echo "Starting udev"
	|echo "/sbin/udev" > /proc/sys/kernel/hotplug
	|echo "Creating devices"
	|UDEVSTART_ON_BOOT=1
	|export UDEVSTART_ON_BOOT
	|/sbin/udevstart
	EOF
    fi

    # Check for IDE modules, might change use_udev
    check_ide_modules $root_dir/lib/modules/$kernel_version

    resolved_modules="$(resolve_modules $kernel_version $modules)"

    # If a SCSI module is loaded, we will have a dependency on scsi_mod
    # for kernels which don't have this built in. In that case, assume
    # that the root file system is on a SCSI device, and also include
    # sd_mod.
    local have_scsi have_sd
    case "$resolved_modules" in
	*/scsi_mod.*)   have_scsi=1
			;;
    esac
    case "$resolved_modules" in
	*/sd_mod.*)	have_sd=1
			;;
    esac
    if [ -n "$have_scsi" -a -z "$have_sd" ]; then
	modules="sd_mod $modules"
	# Re-evaluate module dependencies
	resolved_modules="$(resolve_modules $kernel_version $modules)"
    fi

    # Copy the modules to the initrd
    echo -ne "Modules:\t"
    initrd_is_using_modules=
    while read module params ; do
	[ -z "$module" ] && continue
	echo -n "${module#lib/modules/$kernel_version/} "
	if [ ! -r $root_dir/$module ]; then
	    oops 9 "Module $module not found."
	    continue
	fi
	if ! ( cd ${root_dir:-/} ; cp -p --parents $module $tmp_mnt ) ; then
	    oops 6 "Failed to add module $module. Initrd too small?"
	    return
	fi

	case "$module" in
	    */dasd_mod.*)
		# kernel cmdline dasd parameter is placed into the environment.
		# all we need to do is to have it evaluated at insmod time....:
		params="dasd=\$dasd"
		;;
	    */zfcp.*)
		# FIXME hare: Check against 2.6 whether configuration is
		# still the same ...
		if [ "$zfcp_param" ]; then
			params="map=\"$zfcp_param\""
		fi
		;;
	    */scsi_mod*)
		# We may have SCSI parameters on the kernel command line,
		# but because scsi_mod is a module, those would be ignored.
		# Hack around this by scanning /proc/cmdline in linuxrc.
		params="\$extra_scsi_params${params:+ $params}"

		cat_linuxrc <<-'EOF'
		|# check for SCSI parameters in /proc/cmdline
		|for p in $(cat /proc/cmdline) ; do
		|  case $p in
		|    scsi*|*_scsi_*|llun_blklst=*|max_report_luns=*)
		|      extra_scsi_params="$extra_scsi_params $p"
		|      ;;
		|  esac
		|done
		EOF
	esac

	mp="/$module${params:+ $params}"
	cat_linuxrc <<-EOF
	|echo "Loading ${mp#/lib/modules/$kernel_version/}"
	|insmod $mp
	EOF
	initrd_is_using_modules=1
    done < <(echo "$resolved_modules")
    echo

    if [ -z "$initrd_is_using_modules" ]; then
	echo "none"
    fi

    if has_any_module raid0 raid1 raid5 linear multipath ; then
	echo "Including raidautorun"
	cat_linuxrc <<-EOF
	|echo "raidautorun ..."
	|raidautorun
	|echo "done..."
	EOF
    fi

    if [ -n "$root_lvm" ] ; then
	# need dummy entry so fsck doesn't complain
	cat_linuxrc <<-'EOF'
	|# scan for lvm devices
	|createpartitiondevs
	|#need space for lvm data
	|mount -n -tramfs none /etc/lvmtab.d
	|vgscan
	|vgchange -a y
	|umount -n /etc/lvmtab.d
	|# set the right root device if user specified a lvm root
	|if [ -n "$(root_arg)" ]; then
	|  devn=$(devnumber $(root_arg) 2> /dev/null)
	|  if [ "$devn" -ge 14848 -a "$devn" -lt 15104 ]; then
	|    echo $devn > /proc/sys/kernel/real-root-dev
	|  fi
	|fi
	EOF
    fi

    if [ -n "$root_dm" ] ; then
	cat_linuxrc <<-'EOF'
	|# scan for lvm devices
	|createpartitiondevs
	|#need space for lvm data
	|mount -n -tramfs none /etc/lvm
	|modprobe dm-mod
	|/sbin/devmap_mknod.sh
	|vgscan
	|vgchange -a y
	|umount -n /etc/lvm
	|# set the right root device if user specified a lvm root
	|if [ -n "$(root_arg)" ]; then
	|  devn=$(devnumber $(root_arg) 2> /dev/null)
	|  if [ "$devn" -ge 14848 -a "$devn" -lt 15104 ]; then
	|    echo $devn > /proc/sys/kernel/real-root-dev
	|  fi
	|fi
	EOF
    fi

    if [ -n "$use_udev" ]; then
	sysfs_root=
	if [ -n "$root_dev_t" ]; then
	    echo -e "Udev:\t\tUsing root=$root_dev_t as fallback"
	fi
	cat_linuxrc <<-'EOF'
	|udev_discover_root() {
	|	local node
	|	for item in $(cat /proc/cmdline); do
	|		case $item in
	|		  root=/dev/*)	node=$(expr substr $item 11 99) ;;
	|		  *)		continue ;;
	|		esac
	|	done
	|	if [ -n "$node" ]; then
	|	    echo -n "Waiting for device /dev/$node to appear: "
	|	    for i in 1 2 3 4 5; do
	|		if [ -e /dev/$node ]; then
	|		    path=$(udevinfo -q path -n ${node})
	|		    if [ $? -eq 0 ]; then
	|		        echo " ok"
	|			break
	|		    else
	|		        path=
	|		    fi
	|		fi
	|		sleep 1
	|		echo -n "."
	|	    done
	|	    if [ -n "$path" ]; then
	|	        dev=/sys$path/dev
	|		if [ -f $dev ]; then
	|		    local major minor dev_t
	|		    IFS=":" read major minor < $dev
	|		    dev_t=$(expr $major '*' 256 + $minor)
	|		    echo "rootfs: $entry major=$major minor=$minor dev_t=$dev_t"
	|		    echo $dev_t > /proc/sys/kernel/real-root-dev
	|		    return 0
	|		fi
	|	    elif [ -n "$root_dev_t" ]; then
	|		echo " not found, using fallback"
	|		echo $root_dev_t > /proc/sys/kernel/real-root-dev
	|	    else
	|		echo " not found"
	|	    fi
	|	    return 1
	|	fi
	|
	|}
	|
	|udev_discover_root || {
	|    echo "device nodes:"
	|    cd /dev
	|    for dev in *; do
	|	if [ -e $dev ]; then
	|	    echo $dev
	|	fi
	|    done
	|    cd /
	|}
	EOF
    fi


    if [ -n "$sysfs_root" ]; then
	cat_linuxrc <<-'EOF'
	|sh_basename () {
	|	local IFS=/
	|
	|	set -- $1
	|	eval echo \${$#}
	|}
	|
	|sysfs_set_root_dir () {
	|	local entry name dir=$1 search=$2
	|
	|	for entry in $dir/*; do
	|	  [ -L $entry ] && continue
	|	  [ -d $entry ] || continue
	|
	|	  name=$(sh_basename $entry)
	|	  if [ -f $entry/dev -a $name = $search ]; then
	|		local major minor dev_t
	|		IFS=: read major minor < $entry/dev
	|		dev_t=$(expr $major '*' 256 + $minor)
	|		echo "rootfs: $entry major=$major minor=$minor dev_t=$dev_t"
	|		echo $dev_t > /proc/sys/kernel/real-root-dev
	|		return
	|	  else
	|	    sysfs_set_root_dir $entry $search
	|	  fi
	|	done
	|}
	|
	|sysfs_set_root () {
	|	local root=$1
	|
	|	sysfs_set_root_dir /sys/block $root
	|}
	|
	|discover_root() {
	|	for item in $(cat /proc/cmdline); do
	|		case $item in
	|		  root=/dev/*)	item=$(expr substr $item 11 99) ;;
	|		  *)		continue ;;
	|		esac 
	|		set -- $(IFS=/ ; echo $item)
	|		# FIXME: there are a lot more exceptions below...
	|		case $1 in
	|			cciss)	# /dev/cciss/c0d0p1  ==>
	|				#   /sys/block/cciss!c0d0/cciss!c0d0p1
	|				sysfs_set_root $1!$2 ;;
	|			*)	# /dev/hdXn  ==>  /sys/block/hdX/hdXn
	|				sysfs_set_root $1 ;;
	|		esac
	|	done
	|}
	|
	|discover_root
	EOF
    fi

    if [ -n "$use_pivot_root" ] ; then
	cat_linuxrc <<-EOF
	|# create missing devices
	|createpartitiondevs
	EOF
    fi

    if [ -n "$dhcp_interface" ] ; then
	cat_linuxrc <<-'EOF'
	|case $(root_arg) in
	|/dev/nfs|*:/*|"")
	|   dhcp_mode=1 ;;
	|esac
	EOF
    fi

    if has_module iscsi ; then
	cat_linuxrc <<-'EOF'
	|for o in $(cat /proc/cmdline); do
	|  case $o in
	|    DiscoveryAddress=*)
	|      target="$o" ; iscsi_boot=1 ;;
	|    InitiatorName=*)
	|      initiatorname="$o" ; iscsi_boot=1 ;;
	|  esac
	|done
	|# iscsi boot requires dhcp, regardless of root= format
	|if [ -n "$iscsi_boot" ]; then
	|  dhcp_mode=1
	|fi
	EOF
    fi

    if [ -n "$dhcp_interface" ] ; then
	cat_linuxrc <<-EOF
	|# run dhcp
	|if [ -n "\$dhcp_mode" ]; then
	|  # ifconfig lo 127.0.0.1 netmask 255.0.0.0 broadcast 127.255.255.255 up
	|  # portmap
	|  echo "running dhcpcd on interface $dhcp_interface"
	|  dhcpcd -R -Y -N -t 100000000 $dhcp_interface
	|  [ -s /var/lib/dhcpcd/dhcpcd-$dhcp_interface.info ] || {
	|    echo "no response from dhcp server."
	|    echo 256 > /proc/sys/kernel/real-root-dev
	|    die 0
	|  }
	|  . /var/lib/dhcpcd/dhcpcd-$dhcp_interface.info
	|  kill -9 \$(cat /var/run/dhcpcd-$dhcp_interface.pid)
	|  if [ -n "\$DNS" ]; then
	|    oifs="\$IFS"
	|    IFS=","
	|    for ns in \$DNS ; do
	|      echo "nameserver \$ns" >> /etc/resolv.conf
	|    done
	|    IFS="\$oifs"
	|    if [ -n "\$DOMAIN" ]; then
	|	echo "search \$DOMAIN" >> /etc/resolv.conf
	|    fi
	|    echo 'hosts: dns' > /etc/nsswitch.conf
	|  fi
	|fi
	EOF
    fi

    if has_module iscsi ; then
	cat_linuxrc <<-'EOF'
	|if [ -n "$iscsi_boot" ]; then
	|  echo "Continuous=no" >> /etc/iscsi.conf
	|  echo "ImmediateData=no" >> /etc/iscsi.conf
	|  echo "$target" >> /etc/iscsi.conf
	|  echo "$initiatorname" >> /etc/initiatorname.iscsi
	|
	|  echo "Starting iSCSI"
	|  iscsid
	|  usleep 5000000
	|
	|  # need to redo-this setting up the root dev now that the disk is present
	|  discover_root
	|  createpartitiondevs
	|
	|  # clear dhcp_mode so it looks like we're disk booted...
	|  dhcp_mode=
	|fi
	EOF
    fi

    if [ -n "$dhcp_interface" ]; then
	cat_linuxrc <<-'EOF'
	|if [ -z "$(root_arg)" ]; then
	|  case "$ROOTPATH" in
	|    "") ;;
	|    *:*)
	|	rootdev="$ROOTPATH" ;;
	|    *)
	|	if [ -n "$DHCPSIADDR" ]; then
	|	    rootdev="$DHCPSIADDR:$ROOTPATH"
	|	elif [ -n "$DHCPSNAME" ]; then
	|	    rootdev="$DHCPSNAME:$ROOTPATH"
	|	fi ;;
	|   esac
	|   if [ -z "$rootdev" ]; then
	|	echo "no local root= kernel option given and no root" \
	|	     "server set by the dhcp server."
	|	echo 256 > /proc/sys/kernel/real-root-dev
	|	die 0
	|   fi
	|fi
	EOF
    fi

    cat_linuxrc <<-EOF
	|if [ -z "\$rootdev" ]; then
	|   rootdev=\$(root_arg) || rootdev="$rootdev"
	|fi
	EOF

    if has_module jfs && [ -n "$rootdev" ] ; then
	cat_linuxrc <<-'EOF'
	|# check filesystem if it is of type jfs
	|[ -z "$dhcp_mode" ] && fsck -t jfs "$rootdev"
	EOF
    fi

    if [ -n "$use_selinux" -a -d $tmp_mnt/selinux ]; then
	cat_linuxrc <<-'EOF'
	|echo -n "Loading SELinux policy	"
	|if mount -n -t selinuxfs none /selinux >/dev/null 2>/dev/null ; then
	|  /sbin/load_policy /etc/security/selinux/policy.15
	|  umount /selinux
	|  echo "successful"
	|else
	|  echo "skipped"
	|fi
	EOF
    fi

    if [ -n "$use_pivot_root" ] ; then
	cat_linuxrc <<-'EOF'
	|case "$rootdev" in
	|ROOT=*|LABEL=*)
	|   pivotroot=1 ;;
	|*)
	|   pivotroot=$dhcp_mode ;;
	|esac
	|
	|if [ -n "$pivotroot" ]; then
	|   read_write=
	|   for o in $(cat /proc/cmdline); do
	|	[ $o = rw ] && read_write=1
	|   done
	|
	|   opt=-oro
	|   [ -n "$read_write" ] && opt=-orw
	|   [ -n "$dhcp_mode" ] && opt="${opt},nolock"
	|
	|   # tell kernel root is /dev/ram0, prevents remount after initrd
	|   echo 256 > /proc/sys/kernel/real-root-dev
	|   # mount the actual root device below /mnt
	|   echo "Mounting root $rootdev"
	|   mount -n $opt $rootdev /mnt || die 1
	|
	|   # do pivot-root call
	|   cd /mnt
	|   exec <dev/console >dev/console 2>&1
	|   if [ -d initrd ]; then
	|	exec pivot_root . initrd
	|   elif [ -d mnt ]; then
	|	pivot_root . mnt
	|	exec /bin/umount -n /mnt
	|   else
	|	pivot_root . tmp
	|	exec /bin/umount -n /tmp
	|   fi
	|fi
	EOF
    fi

    # Now create a second initrd with minimal size

    #echo "Creating minimum size initrd image"
    img_size=$(expr $(df -kP $tmp_mnt | sed '1d' | awk '{print $3}') + 2000)
    mkdir $tmp_mnt_small

    dd if=/dev/zero of=$tmp_initrd_small bs=1k count=$img_size 2>/dev/null
    mke2fs -q -F -b 1024 -m 0 -N $image_inodes $tmp_initrd_small \
	2>/dev/null 1>&2
    tune2fs -i 0 $tmp_initrd_small >/dev/null 2>&1

    if ! mount -t ext2 -oloop $tmp_initrd_small $tmp_mnt_small ; then
	error 3 "failed to mount image"
    fi
    is_mounted_small=1

    rmdir $tmp_mnt_small/lost+found
    cp -a $tmp_mnt/* $tmp_mnt_small \
	|| error 6 "copy big image to small image failed"
    chown -R 0:0 $tmp_mnt

    umount $tmp_mnt_small
    is_mounted_small=

    umount $tmp_mnt
    is_mounted=

    gzip -9 $tmp_initrd_small

    if ! cp -f $tmp_initrd_small.gz $initrd_image ; then
	oops 8 "Failed to install initrd"
	return
    fi

    splash_bin=
    [ -x /sbin/splash.bin ] && splash_bin=/sbin/splash.bin
    [ -x /bin/splash ] && splash_bin=/bin/splash
    if [ -n "$splashsizes" -a -n "$splash_bin" ]; then
	if [ -f /etc/sysconfig/bootsplash ]; then
	    . /etc/sysconfig/bootsplash
	fi

	themes_dir=
	if [ -d "$root_dir/etc/bootsplash/themes" ]; then
	    themes_dir="$root_dir/etc/bootsplash/themes"
	elif [ -d "$root_dir/usr/share/splash/themes" ]; then
	    themes_dir="$root_dir/usr/share/splash/themes"
	fi

	echo -ne "Bootsplash:\t"
	if [ -n "$themes_dir" -a \
	     -d "$themes_dir/$THEME" -o -L "$themes_dir/$THEME" ]; then
	    for size in $splashsizes; do
		bootsplash_picture="$themes_dir/$THEME/images/bootsplash-$size.jpg"
		cfgname="$themes_dir/$THEME/config/bootsplash-$size.cfg"
		if [ ! -r $cfgname ] ; then
		    echo "disabled for resolution $size"
		elif [ ! -r $bootsplash_picture ] ; then
		    echo "no image for resolution $size"
		else
		    echo "$THEME ($size)"
		    $splash_bin -s -f $cfgname >> $initrd_image
		fi
	    done
	else
	    echo "no theme selected"
	fi
    fi
}

hex_dev_number() {
    ls -l $1 | awk '{printf "%02x%02x\n", $5, $6}'
}

###################################################################

# working directories
tmp_initrd=$work_dir/initrd
tmp_initrd_small=${tmp_initrd}_small

mounted_proc=
if [ ! -r /proc/mounts ]; then
  mounted_proc=/proc
  mount -t proc proc $mounted_proc
fi

if [ -z "$rootdev" ] ; then
  # no rootdev specified, get current root from /etc/fstab
  while read fstab_device fstab_mountpoint fstab_type fstab_options dummy ; do
    if [ "$fstab_mountpoint" = "/" ]; then
      rootdev="$fstab_device"
      rootfstype="$fstab_type"
      break
    fi
  done < <( sed -e '/^[ 	]*#/d' < $root_dir/etc/fstab)
else
  # get type from /etc/fstab or /proc/mounts (actually not needed)
  x1=$(cat $root_dir/etc/fstab /proc/mounts 2>/dev/null \
       | grep -E "$rootdev[[:space:]]" | tail -n 1)
  rootfstype=$(echo $x1 | cut -f 3 -d " ")
fi

if [ -z "$dhcp_interface" ]; then
    [ -z "$rootdev" ] \
	&& error 1 "No '/' mountpoint specified in $root_dir/etc/fstab"
else
    rootdev=
    rootfstype=nfs
fi

realrootdev="$rootdev"
case "$rootdev" in
    LABEL=*|UUID=*)
	use_pivot_root=1
	# get real root via fsck hack
	realrootdev=$(fsck -N "$rootdev" \
		      | sed -ne '2s/.* \/dev/\/dev/p' \
		      | sed -e 's/  *//g')
	[ -z "$realrootdev" ] \
	    && error 1 "Could not expand $rootdev to real device"
	;;
esac

# check if the root device is an lvm device
root_lvm=
root_dm=
if [ -n "$realrootdev" -a -b "$root_dir/$realrootdev" ] ; then
    dev_hex=$(hex_dev_number $root_dir/$realrootdev)
    root_dev_t=$((0x$dev_hex))

    (( 0x${dev_hex:0:2} ==  58 )) && root_lvm=1
    DMDEV=`sed -n "/device-mapper/s/ .*//p" </proc/devices`
    (( 0x${dev_hex:0:2} == "$DMDEV" )) && root_dm=1
fi

s390_zfcp_proc() {
   zfcp_param=
   if [ ! -s $root_dir/etc/zfcp.conf ] && cat /proc/modules | grep -q "^zfcp"
   then
	fcpconf=$(cat /proc/scsi/zfcp/map)
	if [ -n "$fcpconf" ]; then
	    echo "$fcpconf" > $root_dir/etc/zfcp.conf
	    chmod 644 $root_dir/etc/zfcp.conf
	fi
   fi
   if [ -s $root_dir/etc/zfcp.conf ]; then
	add_module zfcp

	zfcp_param=$(sed -e 's,#.*,,' -e '/^[[:blank:]]*$/d' \
		     $root_dir/etc/zfcp.conf)

	if [ -z "$zfcp_param" ]; then
	    zfcp_param=$(modprobe -v -n zfcp|sed -n '/map=/s/.*zfcp.o //p')
	fi

	if [ -z "$zfcp_param" ]; then
	    error 1 "\
zfcp module loaded but root_dir/etc/zfcp.conf empty.
don't know how to configure zfcp in initrd.

you can save the current configuration with this command:

    cat /proc/scsi/zfcp/map >> root_dir/etc/zfcp.conf
"
	fi
    fi
}

s390_dasd_sysfs() {
    local dev_hex=$(hex_dev_number $rootdev)

    for dir in /sys/block/*/*; do
	if [ -d "$dir" ] && [ -f "$dir/dev" ]; then
	    IFS=":" read tmp_major tmp_minor < $dir/dev
	    if (($tmp_major == 0x${dev_hex:0:2} &&
		 $tmp_minor == 0x${dev_hex:2:2})); then
		path=$dir
		break;
	    fi
	fi
    done

    if [ "$path" ] && [ -d ${path}/../device ]; then
	if [ -r ${path}/../device/discipline ]; then
	    read type < ${path}/../device/discipline

	    case $type in
		ECKD)
		    add_module dasd_eckd_mod
		    ;;
		FBA)
		    add_module dasd_fba_mod
		    ;;
		DIAG)
		    add_module dasd_diag_mod
		    ;;
		*)
		    ;;
	    esac
	else
	    echo "root device $rootdev is not a dasd device."
	fi
    else
	error 1 "\
Could not detect sysfs path for root device $rootdev.
(Broken driver ?)"
    fi
}

s390_dasd_proc() {
    local zipl_conf_with_dasd dasd_module

    if [ -f $root_dir/etc/zipl.conf ] \
       && grep -q '^[[:space:]]*parameters[[:space:]]*=' \
	    $root_dir/etc/zipl.conf; then
	    zipl_conf_with_dasd=1
    fi

    if do_chroot modprobe -c \
       | grep -q '^[[:space:]]*options[[:space:]]\+dasd_mod' ; then
	dasd_module=1
    fi

    if grep -q -e "^dasd" /proc/modules \
       || [ -n "$zipl_conf_with_dasd" ] \
       || [ -n "$dasd_module" ] \
       || has_module dasd_mod ; then

	if [ ! "$zipl_conf_with_dasd" -a ! "$dasd_module" ]; then
	    error 1 "\
The dasd module is required, but no dasd configuration was found in
root_dir/etc/zipl.conf or root_dir/etc/modules.conf."
	fi

	if grep -q ECKD /proc/dasd/devices ; then
	    add_module dasd_eckd_mod
	fi

	if grep -q FBA  /proc/dasd/devices ; then
	    add_module dasd_fba_mod
	fi

	if grep -q DIAG /proc/dasd/devices ; then
	    add_module dasd_diag_mod
	fi
    fi
}

###################################################################

x="$rootdev"
[ -n "$dhcp_interface" ] && x="nfs-root"
[ "$rootdev" != "$realrootdev" ] && x="$x ($realrootdev)"
echo -e "Root device:\t$x (mounted on ${root_dir:-/} as $rootfstype)"

if [ -z "$modules_set" ]; then
    # get INITRD_MODULES from system configuration
    if [ -e $root_dir/etc/sysconfig/kernel ]; then
	. $root_dir/etc/sysconfig/kernel
	modules="$INITRD_MODULES"
    elif [ -e $root_dir/etc/rc.config ]; then
	. $root_dir/etc/sysconfig/kernel
	modules="$INITRD_MODULES"
    fi
fi

###################################################################
# add modules required by features
if [ -n "$root_lvm" ] ; then
    add_module lvm-mod
fi

if [ -n "$root_dm" ] ; then
    add_module dm-mod
fi

if [ -n "$dhcp_interface" ]; then
    # dhcpd reqires the af_packet module, we include it here
    # in case the root FS will be mounted via NFS
    add_module af_packet
fi

if [ "$arch" = s390 ]; then
    # Check if zfcp or dasd modules need to be added automatically:
    if [ -d /sys/block ]; then
	s390_dasd_sysfs
    else
	s390_dasd_proc
	s390_zfcp_proc
    fi
fi

# check if an initrd is needed at all.
#
# on s390 the initrd is always needed as long as we don't set the
# initrd flag in /etc/zipl.conf with YaST.
if [ -z "$modules" -a -z "$root_lvm" -a -z "$root_dm" -a \
     -z "$use_pivot_root" -a \
     -z "$splashsizes" -a "$arch" != s390 -a -z "$use_selinux" ]; then
    ( cd $boot_dir
      rm -f $initrd_images )
    error 0 "No initrd required"
fi

###################################################################

exit_code=0

initrd_images=( $initrd_images )
kernel_images=( $kernel_images )

boot_modules="$modules"
echo -e "Module list:\t$boot_modules"
for ((i=0 ; $i<${#kernel_images[@]} ; i++)); do
    modules="$boot_modules"
    kernel_image=${kernel_images[$i]}
    [ ${kernel_image:0:1} != '/' ] \
    	&& kernel_image=$boot_dir/$kernel_image

    initrd_image=${initrd_images[$i]}
    [ ${initrd_image:0:1} != '/' ] \
    	&& initrd_image=$boot_dir/$initrd_image

    mkinitrd_kernel $kernel_image $initrd_image
    attach_dsdt $initrd_image

    # If the current $kernel_image has a symlink without "-<version>" (e.g.
    # "vmlinuz") pointing to it, create an "initrd" symlink for the
    # corresponding $initrd_image.
    if [ "$(readlink ${kernel_image%%-*})" = \
	 "${kernel_image#$boot_dir/}" ]; then
	rm -f $root_dir/$boot_dir/initrd
	ln -s "${initrd_image#$boot_dir/}" $root_dir/$boot_dir/initrd
    fi
    cleanup
done


cleanup_finish

if [ -e $root_dir/etc/sysconfig/bootloader ]; then
    . $root_dir/etc/sysconfig/bootloader
fi
case $LOADER_TYPE in
  lilo)
    echo "
Run lilo now to update the boot loader configuration."
    ;;
  elilo)
    if [ -x /sbin/elilo ]; then
      /sbin/elilo
    else
      echo "
You may now have to update the elilo boot loader configuration."
    fi
    ;;
  grub)
    ;;
  *)
    if [ -f "$root_dir/etc/zipl.conf" ]; then
	echo "
initrd updated, zipl needs to update the IPL record before IPL!"
    else
	echo "
You may now have to update your boot loader configuration."
    fi
    ;;
esac

exit $exit_code
